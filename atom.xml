<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-10T05:54:52.596Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-10T05:33:02.000Z</published>
    <updated>2022-09-10T05:54:52.596Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下文章请按顺序阅读</p></blockquote><h1 id="5种构建型模式"><a href="#5种构建型模式" class="headerlink" title="5种构建型模式"></a>5种构建型模式</h1><p><a href="https://zhuanlan.zhihu.com/p/85624457">知乎：如何用「设计模式」制作珍珠奶茶？</a></p><h1 id="7-种结构型模式"><a href="#7-种结构型模式" class="headerlink" title="7 种结构型模式"></a>7 种结构型模式</h1><p><a href="https://zhuanlan.zhihu.com/p/91836046">知乎：详解设计模式之结构型模式 （上）</a></p><p><a href="https://zhuanlan.zhihu.com/p/94159179">知乎：详解设计模式之结构型模式 （下）</a></p><h1 id="11-种行为型模式"><a href="#11-种行为型模式" class="headerlink" title="11 种行为型模式"></a>11 种行为型模式</h1><p><a href="https://zhuanlan.zhihu.com/p/135343497">知乎：哪种类型的程序员最容易被“祭天”</a></p><p><a href="https://zhuanlan.zhihu.com/p/166579495">知乎：从零开始学习设计模式之行为型模式（2）</a></p><p><a href="https://zhuanlan.zhihu.com/p/259864836">知乎：如何用设计模式吃自助餐</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以下文章请按顺序阅读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;5种构建型模式&quot;&gt;&lt;a href=&quot;#5种构建型模式&quot; class=&quot;headerlink&quot; title=&quot;5种构建型模式&quot;&gt;&lt;/a&gt;5种构建型模式&lt;/h1&gt;&lt;p&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="cs" scheme="http://example.com/tags/cs/"/>
    
  </entry>
  
  <entry>
    <title>《GAMES101》整理</title>
    <link href="http://example.com/2022/09/10/GAMES101%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2022/09/10/GAMES101%E6%95%B4%E7%90%86/</id>
    <published>2022-09-10T04:20:32.000Z</published>
    <updated>2022-09-10T04:21:33.097Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于《GAMES101》课程<br>整理自CSDN某位博主</p></blockquote><p><a name="bMMtC"></a></p><h1 id="一：基础变换矩阵总结-缩放，旋转，位移"><a href="#一：基础变换矩阵总结-缩放，旋转，位移" class="headerlink" title="一：基础变换矩阵总结(缩放，旋转，位移)"></a>一：基础变换矩阵总结(缩放，旋转，位移)</h1><ol><li>2D线性变换<ol><li>缩放</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446184169-daba343e-a9d8-4c92-85b8-e5c3cef935f4.png" alt="image.png"></p><ol start="2"><li>剪切</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446256386-73deac49-c0bc-446b-aa06-a6c0f1df6b46.png" alt="image.png"></p><ol start="3"><li>旋转</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446285089-cb997900-4f63-4488-b497-73e41b07b405.png" alt="image.png"></p><ol start="2"><li>3D线性变换<ol><li>缩放</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446363718-a49fbe9e-0be5-430c-b3a4-cfd095d71d72.png" alt="image.png"></p><ol start="2"><li>剪切</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446381503-aa8cd679-1069-4a6f-abdd-dd76174bba46.png" alt="image.png"></p><ol start="3"><li>旋转</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446399560-5835fb2e-6267-48f2-80f5-4416de2343d0.png" alt="image.png"></p><ol start="4"><li>绕任意轴旋转：我们把该轴给先旋转到任意的x，y，z轴上，然后就可以应用基本的旋转矩阵，最后再逆旋转回来即可。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446682284-5da0056f-6b97-45ff-92fa-a38e4643ea9c.png" alt="image.png"></p><ol start="3"><li>放射变换<ol><li>位移</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647446493586-f68b2e0c-fc2d-4a6e-91fd-d98218ee0a27.png" alt="image.png"><br><a name="uM5b9"></a></p><h1 id="一-补充-：特征分解和奇异值分解的几何解释"><a href="#一-补充-：特征分解和奇异值分解的几何解释" class="headerlink" title="一(补充)：特征分解和奇异值分解的几何解释"></a>一(补充)：特征分解和奇异值分解的几何解释</h1><p><a href="https://blog.csdn.net/qq_38065509/article/details/105286056?spm=1001.2014.3001.5502">CSDN博客链接</a><br><a name="N2HQk"></a></p><h1 id="二：视图变换-坐标系转化，正交投影，透视投影，视口变换"><a href="#二：视图变换-坐标系转化，正交投影，透视投影，视口变换" class="headerlink" title="二：视图变换(坐标系转化，正交投影，透视投影，视口变换)"></a>二：视图变换(坐标系转化，正交投影，透视投影，视口变换)</h1><p>注：<strong>MVP变换</strong></p><ol><li>模型变换(modeling tranformation)：利用基础的变换矩阵将世界当中的物体调整至我们想要的地方(旋转，平移，缩放)。</li><li>摄像机变换(camera&#x2F;view tranformation)：得到所有可视物体与摄像机的相对位置。把物体和摄像机一起做移动，如果能够把摄像机的坐标轴(假设为u,v,w 分别对应原世界空间中的x,y,z)移动到标准的x，y，z轴，那么此时物体的坐标自然便是相对坐标。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647482981824-912993bb-06ab-47c9-a37c-94e7a4bb6787.png" alt="image.png"></p><ol start="3"><li>投影变换(projection tranformation)<ol><li>正交投影变换(Orthographic Projection Transformation)：是相对简单的一种，坐标的相对位置都不会改变，所有光线都是平行传播，我们只需将物体（可视部分，即上图的那个长方体）全部转换到一个[ −1 , 1]3 的空间之中即可（其中x，y坐标便是投影结果，保留z是为了之后的遮挡检测）。压缩成小立方体是为了之后的计算更加的方便，在转换到屏幕坐标的时候就会重新拉伸回来。</li><li>透视投影变换(Perspective Projection Transformation)：类似人眼看东西的方式，近大远小。<ol><li>由两步组成_Mpersp _&#x3D; _Mortho · Mpersp-&gt;ortho。_即先按前面变换成长方体，再正交投影成[ −1 , 1]3</li></ol></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647484616209-99fd4f84-d3cf-4ab7-9b98-8e2dace83982.png" alt="image.png"></p><ol start="4"><li>将投影所得转换到屏幕空间：[ −1 , 1]2 -&gt; [0,width]∗[0,height]</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647484998016-4552c42b-8b6c-495c-90e1-3fa325277a7f.png" alt="image.png"></p><ol start="5"><li>总结：<img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647485045388-76a47d44-387a-48d0-af9e-8890362a9ca1.png" alt="image.png"></li><li><strong>MVP变换</strong>：<ol><li>M：model 模型变换 (placing objects)</li><li>V：view 视口变换 (placing camera)</li><li>P：projection 投影变换<br><a name="pq3FB"></a></li></ol></li></ol><h1 id="三：直线光栅化的数值微分算法-中点Brensenham算法和三角形的光栅化"><a href="#三：直线光栅化的数值微分算法-中点Brensenham算法和三角形的光栅化" class="headerlink" title="三：直线光栅化的数值微分算法,中点Brensenham算法和三角形的光栅化"></a>三：直线光栅化的数值微分算法,中点Brensenham算法和三角形的光栅化</h1><blockquote><p>简单来说光栅化的目的就是将想要展现的物体给真正现实到屏幕上的过程，因为我们的物体其实都是一个个顶点数据来表示的，如何表这些蕴含几何信息的数据转化为屏幕上的<a href="https://so.csdn.net/so/search?q=%E5%83%8F%E7%B4%A0&spm=1001.2101.3001.7020">像素</a>就是光栅化所考虑的东西。比如说一条直线，究竟该用哪些像素点去逼近它，一个三角形，又用哪些像素集合表示它，这都是光栅化的过程。</p></blockquote><ol><li>屏幕像素的表示</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647486449299-a223b5cc-b21e-430a-8cd9-4d065ecd5ac7.png" alt="image.png"></p><ol start="2"><li>直线光栅化算法（GAMES101没有展开讲）<ol><li>DDA数值微分算法</li><li>中点Bresenham算法</li></ol></li><li>三角形光栅化算法：对每一个像素进行采样，如果像素中心在三角形内，那这个像素点就需要被采用。（利用叉乘判断是否在三角形内）<ol><li>优化方法：用bounding box包围住三角形，只对box内进行采样；找到边界的话，中间的也不用再采样。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647487249524-deab87e1-c034-4185-bd73-950f60accd0a.png" alt="image.png"><br><a name="Z9hwk"></a></p><h1 id="三-补充-：重心坐标-barycentric-coordinates-详解及其作用"><a href="#三-补充-：重心坐标-barycentric-coordinates-详解及其作用" class="headerlink" title="三(补充)：重心坐标(barycentric coordinates)详解及其作用"></a>三(补充)：重心坐标(barycentric coordinates)详解及其作用</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647487680406-da36588c-04e5-41cb-908b-9da22713a8b7.png" alt="image.png"></p><ol><li>几何面积角度求解</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647487785040-35e5c080-257f-446c-b107-ab98cd9b1fb9.png" alt="image.png"></p><ol start="2"><li>坐标系角度求解：以A点为原点，AB,AC分别为新的坐标系的单位向量构建坐标系</li><li>重心坐标的运用<ol><li>判断点是否在三角形内</li><li>用来插值（很常用）<br><a name="DfgiE"></a></li></ol></li></ol><h1 id="四：抗锯齿SSAA及MSAA算法和遮挡剔除Z-Buffer算法"><a href="#四：抗锯齿SSAA及MSAA算法和遮挡剔除Z-Buffer算法" class="headerlink" title="四：抗锯齿SSAA及MSAA算法和遮挡剔除Z-Buffer算法"></a>四：抗锯齿SSAA及MSAA算法和遮挡剔除Z-Buffer算法</h1><blockquote><p>走样示例：我们用有限离散的像素点去逼近连续的三角形，那么自然会出现这种锯齿走样的现象，因为这种近似是不准确的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647488943611-5a8b1167-c8e3-49f3-80d9-012a14e23a25.png" alt="image.png"></p></blockquote><ol><li>反走样<ol><li>超采样反走样(Super Sampling AA，SSAA)<ol><li>下图的计算量变为原来的四倍</li></ol></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647489163060-f1555374-a49d-40de-b989-62c2fb1dab4c.png" alt="image.png"></p><ol start="2"><li>多采样反走样(Multi-Sampling AA，MSAA)<ol><li>是对SSAA的一个改进，我们依然同样会分采样点，但是只会去计算究竟有几个采样点会被三角形cover，计算颜色的时候只会利用像素中心坐标计算一次颜色(即所有的信息都会被插值到像素中心然后取计算颜色)</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647489570599-c3eb5c1f-2b7d-4245-95ee-99136cf308be.png" alt="image.png"></p><ol start="2"><li>Z-Buffer算法<ol><li>步骤<ol><li>Z-Buffer算法需要为每个像素点维持一个深度数组记为zbuffer，其每个位置初始值置为无穷大（即离摄像机无穷远）。</li><li>随后我们遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于zbuffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。</li></ol></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647489823251-d9ed93ae-d939-44aa-9606-183aa9d6215e.png" alt="image.png"></p><blockquote><p>tips:这里的MSAA说的有些简单，实际操作的时候，同样会维护所有子采样点的color buffer和depth buffer，每次对pixel中心计算shading的时候，会根据depth值(因为可能不止一个三角形拥有这个像素)和三角形覆盖关系判断是否把颜色值写入。<br>如下面这个例子(灵魂画手见谅)<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647490118110-1a44b202-7a68-41b2-81bb-6f4cc0bce11a.png" alt="image.png"><br>红色和蓝色三角形同时覆盖了黑色的像素中心，那么在第一次渲染红色三角形的时候会将颜色写入1,3号采样点，同时更新depth buffer，但此时2,4号采样点的depth buffer依然是无穷(初始值)，所以在渲染到蓝色三角形的时候会将蓝色写入2,4号并更新depth buffer。如果还有更多的三角形覆盖黑色像素中心的话，会重复上述这个过程，即根据是否覆盖以及深度值判断是否写入颜色值。最后将这4个子采样点颜色平均即可。<br>个人感觉这种MSAA的效果是没有SSAA好的，因为MSAA相当于默认了采样点的颜色与像素中心差别不大，导致了误差的存在，特别是在纹理映射的时候，如果纹理过大，MSAA可能完全没啥效果，因为一个屏幕空间像素覆盖了多个纹理空间像素，屏幕空间像素内微小的采样点距离差距都会导致在纹理空间中完全不一样的颜色信息，如果还是只做一次屏幕空间像素中心的shading的话，误差就会非常大。</p></blockquote><p><a name="E5B72"></a></p><h1 id="五：局部光照模型-Blinn-Phong-反射模型-与着色方法-Phong-Shading"><a href="#五：局部光照模型-Blinn-Phong-反射模型-与着色方法-Phong-Shading" class="headerlink" title="五：局部光照模型(Blinn-Phong 反射模型)与着色方法(Phong Shading)"></a>五：局部光照模型(Blinn-Phong 反射模型)与着色方法(Phong Shading)</h1><blockquote><p>此环节做shading，处理光照</p></blockquote><p>光线类型：1、镜面反射 2、漫反射 3、环境光</p><ol><li>泛光模型（只能看到一个物体的平面形状）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647573172428-a1f1c33a-c51a-48a6-88c0-7af0dfbde32b.png" alt="image.png"></p><ol start="2"><li>Lambert漫反射模型</li></ol><ul><li>概念图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647573665100-92a076cd-bcc5-4ddd-b3b5-7ec133ed3632.png" alt="image.png"></p><ul><li>数学公式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647573740106-3547928a-09e9-49b4-b33a-cfc5932feb43.png" alt="image.png"></p><ul><li>效果图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647574418801-6fde3755-0d72-4b91-bca4-36d872996a05.png" alt="image.png"></p><p>](<a href="https://blog.csdn.net/qq_38065509/article/details/105691559">https://blog.csdn.net/qq_38065509/article/details/105691559</a>)</p><ol start="3"><li>Phong反射模型</li></ol><ul><li>直观图与数学公式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647575225236-4d56c180-b4b5-4ce4-b979-2d70ab2ff69d.png" alt="image.png"></p><ul><li>效果图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647575595649-63cb91ed-55ff-4846-a3a0-84688aba08c0.png" alt="image.png"></p><ol start="4"><li>Blinn-Phong反射模型（与Phong相比只是加速了计算，引入了半程向量）</li></ol><ul><li>直观图与数学公式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647575996690-a91e063a-9bb2-472b-9aae-e66c26110cba.png" alt="image.png"></p><ul><li>效果图与总结</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647576090762-22969149-309b-4c4b-aca3-e7124a350e90.png" alt="image.png"></p><ol start="5"><li>着色方法（频率）<ol><li><strong>Flat Shading</strong><ol><li>面着色，顾名思义以每一个面作为一个着色单位。模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面，效果如下：</li></ol></li><li><strong>Gouraud Shading</strong></li></ol></li></ol><ul><li>由面的法向量求解顶点处的法向量：将所有共享这个点的面的法线向量加起来求均值，最后再标准化就得到了该顶点的法线向量了。</li><li>注：三角形中间的属性由顶点的属性利用中心坐标插值得到。</li></ul><p>(tips:1.这里有两个tips可以注意一下，首先重心坐标一定要是原世界坐标空间中的重心坐标，但实际计算中一般会使用投影之后的二维平面来计算重心坐标，存在着一个误差需要校正，这会在下一节笔记中展开来谈。<br />2. 第二点，其实按理来说Gouraud用的是双线性插值(会在之后的贝塞尔曲线中具体讲解)，但是道理都是相同的，本文这里为了方便就直接用了重心坐标插值）</p><ol start="3"><li><strong>Phong Shading</strong></li></ol><ul><li>由顶点法向量利用重心坐标插值出面内法向量，再进行计算属性。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647584327038-e34fc821-2583-43cd-ab62-070eff317baa.png" alt="image.png"></p><ol start="6"><li>在模型精度较高时，就没必要使用计算量较大的后两种方式</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647584409663-5afea9e1-50b3-49d5-9709-1625e225e013.png" alt="image.png"></p><ol start="7"><li>Note：变换法线向量<blockquote><p>有的读者可能会疑问，法线向量不是一直存在于世界坐标空间之中吗，为什么要去变换他呢，其实原因很简单，<strong>因为模型变换可能会导致模型位置形状发生改变</strong>，如果属于该模型的各个三角形面的法线向量不跟着改变的话，那么此时所记录的法线向量就是错误的。<strong>因此法线向量一定也要跟着模型本身发生改变。</strong><br>那么是否简单的将作用在模型本身的变换也作用在对应的法线向量之上就可以了呢？<strong>答案是否定的</strong>。</p></blockquote></li></ol><p>直接放结论：<a href="https://blog.csdn.net/qq_38065509/article/details/105691559?spm=1001.2014.3001.5502">想看细节点这里</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647585204615-83b4b01b-9182-43d5-a784-15501ce7f558.png" alt="image.png"><br><a name="j8udw"></a></p><h1 id="六：正确使用重心坐标插值-透视矫正插值-Perspective-Correct-Interpolation-和图形渲染管线总结"><a href="#六：正确使用重心坐标插值-透视矫正插值-Perspective-Correct-Interpolation-和图形渲染管线总结" class="headerlink" title="六：正确使用重心坐标插值(透视矫正插值(Perspective-Correct Interpolation))和图形渲染管线总结"></a>六：正确使用重心坐标插值(透视矫正插值(Perspective-Correct Interpolation))和图形渲染管线总结</h1><blockquote><p>我们的<strong>重心坐标往往都是在屏幕空间下所得到的</strong>，如果<strong>直接使用屏幕空间下的重心坐标进行插值会造成一定的误差</strong>，与在view space下是不一样的，那么本节内容就会具体介绍如何矫正这种误差，利用屏幕空间下的重心坐标达到正确的插值。在此之后也会对到目前为止的所有内容进行总结，即图形渲染管线。</p></blockquote><ol><li>透视矫正插值(Perspective-Correct Interpolation)</li></ol><ul><li>一个误差示例如下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647585455993-f3e124de-d493-48d4-bdb4-606f45d0c2d6.png" alt="image.png"></p><ul><li>矫正利用了三角形的相似性，求解过程本笔记略<br><a name="ohtig"></a></li></ul><h2 id="渲染管线总结"><a href="#渲染管线总结" class="headerlink" title="渲染管线总结"></a>渲染管线总结</h2><p><a href="https://zhuanlan.zhihu.com/p/137780634">讲解很好的一个知乎文章</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1650437510815-f89ce55a-5591-4228-a991-f27ee21e961a.png" alt="image.png"><br><a name="vX1ZA"></a></p><h3 id="1、应用阶段"><a href="#1、应用阶段" class="headerlink" title="1、应用阶段"></a>1、应用阶段</h3><p>主要由CPU负责，且完全由开发人员掌控。在这个阶段，CPU将决定传递给GPU什么样的数据（譬如渲染目标场景中的灯光、场景的模型、摄像机的位置），有时候还会对这些数据进行处理（譬如只递给GPU可以被摄像机看见的元素，其他不可见的元素被剔除（culling）出去），并且告诉GPU这些数据的渲染状态（譬如纹理、材质、着色器等）。<br><a name="RKTBO"></a></p><h3 id="2、几何阶段"><a href="#2、几何阶段" class="headerlink" title="2、几何阶段"></a>2、几何阶段</h3><p>由GPU主导，<strong>绿色</strong>表示开发者可以完全编程控制的部分，<strong>虚线外框</strong>表示此阶段不是必需的，<strong>黄色</strong>表示开发者无法完全控制的部分（但可以进行一些配置），<strong>紫色</strong>表示开发者无法控制的阶段（已经由GPU固定实现）。</p><ol><li><strong><del>放入显存与Draw Call</del></strong></li><li><strong>顶点着色器</strong></li></ol><p>进行模型转化与相机转换（即MVP变换中的M和V）<br />顶点着色器中，我们无法创建或销毁任何一个顶点，也无法得到当前处理的这个顶点与其他顶点的关系。<br /><strong>此阶段还可以做的：</strong></p><blockquote><p>坐标变换</p></blockquote><p>开发者可以编写程序在这个阶段修改顶点的坐标，诸如流动、摇曳等与顶点位置相关的动画操作都可以实现。上图通过坐标变换改变了原有球的形状。</p><blockquote><p>逐顶点色彩信息处理</p></blockquote><p>开发者可以在这个阶段计算每个顶点的光照信息，计算光照、阴影等。图中小球即通过各顶点法向与光源坐标进行了简单的漫反射计算。当然除了计算光照，其他与顶点颜色相关的操作<strong>都可以在这个阶段里进行</strong>。值得一提的是，这里仅仅是“信息处理”，<strong>还不是真正的着色</strong>，可以理解为“为接下来的着色计算提供一些信息”。</p><ol start="3"><li><strong>曲面细分着色器（非必需）</strong></li><li><strong>几何着色器（非必需）</strong></li></ol><p>开发者可以控制GPU对顶点进行增删改操作。</p><ol start="5"><li><strong>投影</strong></li></ol><p>正交投影与透视投影（棱台）<br />计算时需要考虑远裁剪平面（Far Clipping Plane）和近裁剪平面(Near Clipping Plane)<br />透视投影需要额外考虑视野(Field of View)，即视锥体张开的角度，正交投影需要额外考虑尺寸（Size），这个值用于衡量视锥体底的大小。</p><ol start="6"><li><strong>裁剪</strong></li></ol><p>目的就是把摄像机看不到的顶点剔除出去，使他们不被渲染到。</p><ol start="7"><li><strong>屏幕映射</strong></li></ol><p>[-1,1] -&gt; [width,height]<br><a name="IgdJU"></a></p><h3 id="3、光栅化阶段"><a href="#3、光栅化阶段" class="headerlink" title="3、光栅化阶段"></a>3、光栅化阶段</h3><ol><li><strong>图元组装（也称为三角形设置）</strong></li></ol><p>通俗的说就是把相关的两个顶点“连连看”，有些能构成面，有些只是线，有些就只能一个点。</p><ol start="2"><li><strong>三角形遍历</strong></li></ol><p>检验屏幕上的某个像素是否被一个三角形网格所覆盖，被覆盖的区域将生成一个片元（Fragment）。<br />值得注意的是，<strong>片元不是真正意义上的像素，而是包含了很多种状态的集合</strong>（譬如屏幕坐标、深度、法线、纹理等），这些状态用于最终计算出每个像素的颜色。<br />这一阶段涉及了<strong>抗锯齿</strong>操作<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1650439670646-e181fc80-1d24-46fa-8ce5-e913eea3990e.png" alt="image.png"></p><ol start="3"><li><strong>片元着色器（也被称为像素着色器）</strong></li></ol><p>为每个片元计算颜色，<strong>布林冯等等</strong>。<br />程序员可以引入<strong>纹理、法线贴图、高度图、糙度图等等</strong>。虽然片元着色器可以完成很多重要效果，但它仅可以影响单个片元。也就是说，当执行片元着色器时，它不可以将自己的任何结果直接发送给它附近的片元的。</p><ol start="4"><li><strong>逐片元操作</strong></li></ol><p>对片元进行各种测试并合并<br />在OpenGL中，主要的测试有：裁剪测试（Scissor Test）、透明度测试（Alpha Test）、模板测试（Stencil Test）以及深度测试（Depth Test）。这个阶段是高度可配置的。</p><hr><p><strong>GAMES101的整理</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647586130337-291baa7d-e6c7-4be2-ace4-7411d14a2ba1.png" alt="image.png"></p><ol><li>顶点处理：<ol><li>对所有的顶点数据进行Model，View，和Projection的变换，最终得到投影到二维平面的坐标信息(同时为了Zbuffer保留深度z值)。如果超出观察空间的会被剪裁掉。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647587709586-76cb2c10-6e5c-4318-a65d-b525ca8c11d4.png" alt="image.png"></p><ol start="2"><li>三角形处理<ol><li>将所有的顶点按照原几何信息，变成三角面，每个面由3个顶点组成。得到了许许多多个三角形之后，接下来的操作自然就是三角形光栅化了。</li></ol></li><li>三角形光栅化<ol><li>三角形遍历，确定哪些在三角形内的点可以被显示</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647587761530-5b5f3512-b377-4941-a1ee-e8a67a4bc1ba.png" alt="image.png"></p><ol start="4"><li>顶点处理+片元处理<ol><li>那么<strong>如何确定每个像素点或者说片元(Fragement)的颜色呢</strong>？[注：<strong>片元可能比像素更小</strong>，如MSAA抗拒齿操作的进一步细分得到的采样点]。那自然就是<strong>着色</strong>了，也就是片元处理阶段应该做的。</li><li>这阶段有“顶点处理”的操作，是因为我们需要顶点信息对三角形内的点进行属性插值</li><li>(tips：当然<strong>也可以直接在顶点处理阶段就算出每个顶点的颜色值</strong>，如Gouraud Shading一样)。当然这一阶段也少不了<strong>Z-Buffer</strong>来帮助确定，哪些像素点应该显示在屏幕上，哪些点被遮挡了不应该显示</li><li>(tips:其实在片元处理阶段我们也可以去做<strong>texture mapping</strong>，利用texture的信息来<strong>代替blinn-phong模型漫反射系数来当作颜色</strong>，这一部分的内容会在下一节笔记中叙述！)</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647587784783-dbb4f98c-c57e-44ed-a189-5e4ed141861b.png" alt="image.png"></p><ol start="5"><li>帧缓冲区处理<ol><li>就是将所有的像素颜色信息整合在一起，输送给显示设备加以显示。这也就完成了整个图形渲染管线了。<br><a name="jHc5W"></a></li></ol></li></ol><h1 id="七：纹理映射-Texture-Mapping-及Mipmap技术"><a href="#七：纹理映射-Texture-Mapping-及Mipmap技术" class="headerlink" title="七：纹理映射(Texture Mapping)及Mipmap技术"></a>七：纹理映射(Texture Mapping)及Mipmap技术</h1><blockquote><p>本节，我们会具体的讨论如何利用纹理映射让场景拥有丰富的颜色信息，以及纹理贴图精度大小所带来的问题，怎么去解决，最后将会介绍Bump Mapping和Displacement Mapping</p></blockquote><ol><li>纹理映射(Texture Mapping)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647588328563-2218ea21-2cf3-4408-b01d-dbbf16c06622.png" alt="image.png"></p><ul><li>无论是球上的图案，以及地板的木头纹理都呈现出了不同的颜色信息，那么回想在讲解<strong>Blinn-Phong反射模型</strong>的时候曾提到，<strong>一个点的颜色是由其漫反射系数决定的</strong>，反射什么颜色的光，人眼就能看见什么颜色。那么针对上面这幅图，难道要去针对每一个点自己去设定一个颜色吗？还是说有什么更方便的方法呢？那便是<strong>纹理映射</strong>了！</li><li>Texture需要有 从3维World space到2维Texture space的一个映射关系<ul><li>如果在三维world space中每个顶点的信息之中存储下该顶点在texture space的(u,v)坐标信息，自然而然的就直接的得到了这种映射关系。<blockquote><p>至于一个顶点所对应在纹理空间的坐标是怎么得到的，这就并不是程序员们关心的了，美术大大们会帮我们最好的。<br>有一种特殊的纹理称为tile，这种纹理的特征是重复拼接之后上下左右都是连续的，因此这种纹理可以复制很多张贴在墙面或地板上。</p></blockquote></li></ul></li></ul><ol start="2"><li>纹理过小和纹理过大的问题及解决方案<ol><li>纹理过小<ol><li>引发的问题：假如我们把一张100x100的纹理贴图应用在一500x500的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应(u,v)坐标在texture贴图下最近的那个像素点，往往会造成严重的走样。<ol><li>下图红色的是像素映射到纹理中的点，黑色的是纹理正常的排布点</li></ol></li><li>双线性插值</li></ol></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647590506187-8d36c043-9d4f-4165-95e2-5668fd414880.png" alt="image.png"></p><ol start="2"><li>纹理过大<ol><li>引发的问题：想用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真！(从信号的角度来说就是，采样频率过低无法还原信号原貌)</li></ol></li></ol><ul><li>一个示例</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647591096020-ec5d228f-697f-47cd-8115-8fc9165bbb96.png" alt="image.png"></p><ul><li>footprint（一个像素覆盖的区域在纹理中对应的面积）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647591444993-c0171505-fe26-4bbf-a26f-ac115f282ebc.png" alt="image.png"></p><pre><code>  - 超采样（把一个像素细分为更多采样点）可以解决，但计算量过大  2. **Mipmap**：换一种想法，不去超采样，仅仅是求出每个屏幕像素所对应的footprint里所有texels（纹理空间的像素）的的颜色均值，从点查询Point Query迈向区域查询Range Query。     1. 不同的屏幕像素所对应的footprint size是不一样大小的，看下图这样一个例子。远处圆圈里的footprint必然比近处的要大，因此必须要准备不同level的区域查询才可以。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647591801662-0720d83b-3678-40c7-9823-79c1fd45965b.png" alt="image.png"></p><pre><code>     2. 如何确定使用哪个level的texture呢？利用屏幕像素的相邻像素点估算footprint大小再确定level D。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647592722966-fc8b356e-5dca-4a5f-acf9-53107898ec12.png" alt="image.png"></p><blockquote><p>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，二者取最大值，计算公式如图中所示，那么level D就是这个距离的log2值 (D &#x3D; log2L) ! 这不难理解，读者可以具体取几个例子比如L &#x3D; 1，L &#x3D; 2，L &#x3D; 4，看看是否符合这样的计算即可。</p></blockquote><ul><li>这里D值算出来是一个连续值，<strong>并不是一个整数</strong>，有两种对应的方法<ul><li>四舍五入取得最近的那个level D</li><li>利用D值在向下和向上取整的两个不同level进行3线性插值<ul><li>所谓3线性插值，就是在向下取整的D level上进行一次双线性插值(前文提过)，再在D+1 level之上进行一次双线性插值，这二者数据再根据实际的连续D值在向下和向上取整的两个不同level之间的比例，再来一次线性插值，而这整体就是一个三线性插值了。</li></ul></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647593153455-b2e64487-fe73-498c-946a-4dfff5c3a194.png" alt="image.png"></p><pre><code>  3. 各向异性过滤Mipmap  - 接着上文的远处产生过曝的问题继续来谈，产生这种现象的原因是因为，所采用的不同level的Mipmap默认的都是正方形区域的Range Query，然而真实情况并不是如此</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647593351914-c34bbd98-78fd-49d7-a757-9a409d34e678.png" alt="image.png"></p><pre><code>  - 示例</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647593420403-292687da-07d7-4725-877d-92165495840d.png" alt="image.png"></p><pre><code>  - (Note:其实各向异性过滤并不能解决 diagonal（对角）的footprint，因为各向异性**只能解决水平或竖直的不同大小的矩形footprint**，所以针对diagonal的footprint,一般是去sample更多的点，或者提前算好diagonal 过滤的texture)</code></pre><p><a name="Srn8p"></a></p><h1 id="八：纹理映射的应用-法线贴图，凹凸贴图与阴影贴图等相关应用的原理详解"><a href="#八：纹理映射的应用-法线贴图，凹凸贴图与阴影贴图等相关应用的原理详解" class="headerlink" title="八：纹理映射的应用(法线贴图，凹凸贴图与阴影贴图等相关应用的原理详解)"></a>八：纹理映射的应用(法线贴图，凹凸贴图与阴影贴图等相关应用的原理详解)</h1><blockquote><p>纹理映射的应用远不止单单作为diffuse的反射系数来表现出不同颜色。本文会详细介绍一些主要的纹理映射的应用及其原理，首先从法线映射和切线空间开始说起。</p></blockquote><ol><li>Normal Maps及切线空间</li></ol><ul><li><p>Texture上可以存储3维的颜色信息作为漫反射系数，那么自然也就可以存储法线向量的信息！同样利用(u,v)坐标去查询每个点的法线向量，而不使用原来模型法线信息，达到各种不同的效果，这就是Normal Maps。</p><blockquote><p>倘若将一个高精度模型法线信息套用在低精度模型之上，会使低精度模型的渲染效果有着巨大的提升。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647594361242-16d04bcd-95b3-45ec-9453-f4f6fb6f7d8c.png" alt="image.png"></p></blockquote></li><li><p>如何在存储这些法线信息呢？两种方法</p><ul><li>一种可选的方法是，存储object space下的法线向量坐标(这会使得法线贴图看起来五颜六色的)，好处是取出来转换到世界坐标就可以直接使用，坏处是一旦该法线向量的三角形面发生了变形，那么该法线向量就不再正确。</li><li>第二种方法，存储切线空间之的法线向量坐标(这会使得法线贴图大部分呈蓝色，原因下文会提)。<ul><li>TBN矩阵：<a href="https://blog.csdn.net/qq_38065509/article/details/106050879?spm=1001.2014.3001.5502">原博客在这</a></li></ul></li></ul></li></ul><ol start="2"><li>Bump Maps（凹凸贴图）<ol><li>Bump Maps其实与Normal Maps十分类似，Normal Maps直接存储了法线信息，而Bump Maps存储的是该点逻辑上的相对高度(可为负值)，<strong>该高度的变化实际上表现了物体表面凹凸不平的特质</strong>，利用该高度信息，再计算出该点法线向量，最后再利用该法线计算光照，这就是Bump Maps的过程，只不过比直接的Normal Maps多了一步从height到normal向量。</li><li>如何从相对高度计算出法线向量？<ol><li>二维情况</li></ol></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647595161481-902e951f-5115-4ee9-82ec-e4dc3147907b.png" alt="image.png"></p><pre><code>  2. 三维情况</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647595222100-d63853b9-08f0-4b40-b801-7a83fdc49de5.png" alt="image.png"></p><ul><li><strong>正如最后一点所标注的，所有计算出来的法线都是局部坐标即切线空间之下，因此还需要左乘[t b n]矩阵转到(世界)相机坐标系之下得到正确法向！</strong></li></ul><ol start="3"><li>Displacement Maps（位移贴图）</li></ol><ul><li>Displacement Maps其实又与Bump Maps十分类似了，Bump Maps是逻辑上的高度改变，而Displacement Maps则是物理上的高度改变，二者的区别就在此处，可以通过物体阴影的边缘发现这点：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647602656533-f57d60d3-6ca4-4a2e-9703-f88cca16bd35.png" alt="image.png"></p><ol start="4"><li>Environment Maps</li></ol><ul><li>顾名思义就是将环境光存储在一个贴图之上。想象这样一个情形，光照离我们的物体的距离十分遥远，因此对于物体上的各个点光照方向几乎没有区别，那么唯一的变量就是人眼所观察的方向了，因此各个方向的光源就可以用一个球体进行存储,即任意一个3D方向，都标志着一个texel：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647602848906-d75399d2-d5aa-47fe-92b6-e00c93cc4df9.png" alt="image.png"></p><ul><li>再投影转换到平面上就得到了环境texture</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647607272020-f07d2c2d-5595-4ebf-a76a-aa45b691d80f.png" alt="image.png"></p><ul><li>环境映射伪代码<ul><li>光线追踪时。可以看到在光线未能撞击物体的时候，会利用光线方向求得展开之后贴图上的(u,v)坐标，再去查询颜色返回。</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647607406023-f3a9e835-a530-4568-a62a-2a5bbb1b1bd8.png" alt="image.png"></p><ul><li>Blinn-Phong时。只需增加一项反射的颜色即可。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647607436362-c75af111-6485-44f2-9c5f-847496a46324.png" alt="image.png"></p><ul><li>用球体来储存，扭曲比较明显。另外一种存储的方法就是Cube Map，也就是天空盒，但是中间多了一步从方向到面上的计算。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647607680589-8f24e71e-f37a-4bee-8ac1-9beb1d11e658.png" alt="image.png"></p><ol start="5"><li>阴影贴图Shadow Maps<ol><li>第一步，把光源当做一个摄像机让它去看，去渲染整个场景一遍从而得到从光源视角的深度Buffer，记为dmap(注：此时得到的这个dmap即为shadow maps)</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647608695006-58ce35a9-39de-4696-b908-bf2a59df7e53.png" alt="image.png"></p><ol start="2"><li>第二步，从设定好的摄像机位置去真正的渲染场景得到摄像机视角的深度Buffer，记为d</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647608729415-09f51b26-e023-4836-a158-7c89c93cce9b.png" alt="image.png"></p><ol start="3"><li>第三步，将所有摄像机视角可见点，利用光源视角下的那一套投影矩阵，重新投影回光源，找到与之对应的dmap上的深度值<ol><li>如果该点在dmap上的深度值与d上的深度值相等，则说明此点可被光源与摄像机共同看见，因此不在阴影中，如下图这种情况</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647608799252-6fbb1d9a-a06d-48fb-bac3-d1998d534bc1.png" alt="image.png"></p><pre><code>  2. 如果该点在dmap上的深度值小于d上的深度值，则说明此点不可被光源看见，但摄像机看得见，即该点前方有物体遮挡，因此在阴影中，如下图这种情况</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647608827585-f726d459-74ce-4727-8c23-5e0cb55cd2ac.png" alt="image.png"></p><ul><li>如此便能确定每个可见像素点是否在阴影之中了，<strong>如果在阴影之中就不去计算Blinn-Phong中的镜面反射项与漫反射项。</strong></li><li>效果图示例</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647609766118-4765c846-6bb4-4319-955b-7eef33fd4f30.png" alt="image.png"></p><ul><li>产生的shadow map示例</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647609810856-3893f20d-d00c-41c5-82a0-fb2848837687.png" alt="image.png"></p><ol><li>对于shadow maps还有几点小细节<ol><li>浮点数难以判断相等，所以一般会有一个tolerance</li><li>shadow maps查询时不采用双线性插值，只寻找最近的点，因为倘若插值发生在物体边缘时，与邻接点的深度差距很大，会导致插值结果会有很大的误差</li><li><strong>只适用于点光源，产生的是硬阴影。</strong>对于非点光源，阴影的边缘会有过渡的情况，从而产生软阴影现象</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647609958222-5c5be63c-1598-4483-991c-39fd5074c894.png" alt="image.png"><br><a name="Am2V3"></a></p><h1 id="九：几何1—隐式曲面-代数形式-CSG-距离函数-分型几何-与显式曲面"><a href="#九：几何1—隐式曲面-代数形式-CSG-距离函数-分型几何-与显式曲面" class="headerlink" title="九：几何1—隐式曲面(代数形式,CSG, 距离函数,分型几何)与显式曲面"></a>九：几何1—隐式曲面(代数形式,CSG, 距离函数,分型几何)与显式曲面</h1><ol><li>隐式曲面(Implicit Surface)与显示曲面(Explicit Surface)的特点<ol><li>隐式曲面：指的是并不会告诉你任何点的信息，只会告诉你该曲面上所有点满足的关系。例如：_x_2+_y_2+_z_2&#x3D;1<ol><li>优点：十分容易的判断出一点与曲面的关系</li><li>缺点：因为没有给出任何点的信息，因此如何采样到曲面上具体的点是一个很难的问题</li></ol></li><li>显式曲面：是与隐式曲面相对应的，所有曲面的点被直接给出，或者可以通过映射关系直接得到<ol><li>优缺点与隐式曲面相反</li></ol></li></ol></li><li>具体的几种隐式曲面<ol><li>代数曲面(Algebraic Surfaces)</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647746002410-eef48648-574e-4137-9517-f5233b0ebbc6.png" alt="image.png"></p><ol start="2"><li>Constructive Solid Geometry(CSG)：指的是可以对各种不同的几何做布尔运算，如并，交，差</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647746034263-1533f3a4-da49-4c96-b31d-d348b494e965.png" alt="image.png"></p><ol start="3"><li>符号距离函数(Signed Distance Function)：可以通过距离函数来得到几何形体混合的效果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647746142382-1ccb1437-4d66-4bec-8106-c80831052a46.png" alt="image.png"></p><ol start="4"><li>水平集(Level Set)：与SDF很像(像是SDF的一种特殊形式)，也是找出函数值为0的地方作为曲线，但不像SDF会空间中的每一个点有一种严格的数学定义，而是对空间用一个个格子去近似一个函数，如下。对该面内的每一个点利用已经定义好的格子值进行双线性插值(在纹理映射一节已讲解)就可以得到任意一点的函数值，找出所有&#x3D;0的点作为曲面。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647746296871-af09d304-eda9-4c0c-b9ed-090b13a895eb.png" alt="image.png"></p><ol start="5"><li>分型几何(Fractals)：是指许许多多自相似的形体最终所组成的几何形状，有点递归的意思。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647746405067-a71ac183-9b67-45ff-89bf-de41f278ee9a.png" alt="image.png"></p><ol start="3"><li>具体的集中显式曲面<ol><li>点云(Point Cloud)：很多点构成的曲面</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647746453088-f53dd68a-00e8-48a8-be59-9637f2f290ba.png" alt="image.png"></p><ol start="2"><li>多边形网格(Polygon Mesh)：简单来说通过定义各个多边形面的顶点以及顶点之间的连接关系就可以得到许许多多的三角形面或是四边形面，再通过这些面来近似表现出我们想要的模型效果。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647746488909-9e60cffc-4566-4607-8459-017ebedfd09c.png" alt="image.png"></p><p><a name="iIszF"></a></p><h1 id="十：几何2—贝塞尔曲线-Bezier-Curves-与贝塞尔曲面-Bezier-Surfaces"><a href="#十：几何2—贝塞尔曲线-Bezier-Curves-与贝塞尔曲面-Bezier-Surfaces" class="headerlink" title="十：几何2—贝塞尔曲线(Bézier Curves)与贝塞尔曲面(Bézier Surfaces)"></a>十：几何2—贝塞尔曲线(Bézier Curves)与贝塞尔曲面(Bézier Surfaces)</h1><ol><li>贝塞尔曲线(Bézier Curves)<ol><li>其核心所在就是多次的线性插值，并在生成的新的顶点所连接构成的线段之上<strong>递归的执行这个过程</strong>，直到得到最后一个顶点。控制系数是有规律的，二项分布，伯恩斯坦多项式与之对应。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647747634515-2957a6eb-96e4-4676-a43e-c1a37fe32901.png" alt="image.png"></p><ol start="2"><li>性质概括<ol><li>必定经过起始与终止控制点</li><li>必定经与起始与终止线段相切</li><li>具有仿射变换性质，可以通过移动控制点移动整条曲线</li><li>凸包性质，曲线一定不会超出所有控制点构成的多边形范围</li></ol></li><li>高阶的贝塞尔曲线很难控制局部的贝塞尔曲线形状<ol><li>解决方案：分段贝塞尔曲线</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647748189217-5fd36454-5452-46c8-95f1-29ede0c203fa.png" alt="image.png"></p><ol start="4"><li>此外还有B样条、NURBS曲线等等</li><li>贝塞尔曲面(Bézier Surfaces)：由贝塞尔曲线再插值</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647748395387-db5814df-9470-4ba1-bb3c-4fed614f4101.png" alt="image.png"><br><a name="AtuEo"></a></p><h1 id="十一：几何3—曲面细分-Mesh-subdivision-与曲面简化-Mesh-Smplication"><a href="#十一：几何3—曲面细分-Mesh-subdivision-与曲面简化-Mesh-Smplication" class="headerlink" title="十一：几何3—曲面细分(Mesh subdivision)与曲面简化(Mesh Smplication)"></a>十一：几何3—曲面细分(Mesh subdivision)与曲面简化(Mesh Smplication)</h1><ol><li>曲面细分：是指将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647748959677-ed4a8da8-138e-42ef-9695-41a69231d88a.png" alt="image.png"></p><ol><li>Loop细分:是一种专门针对三角形面的细分方法<ol><li>生成更多三角形或顶点</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647749743495-9acd4b2a-238e-4b7b-b71c-4606763952e6.png" alt="image.png"></p><pre><code>  2. 调整这些三角形或顶点的位置     1. 分为新的顶点与旧的顶点</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647749756587-830ee6b6-d8e7-40c3-aaf0-9ee5e0c14f97.png" alt="image.png"></p><ol start="2"><li>Catmull-Clark细分：还可以处理四边形面</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647749837107-2dbf4338-878c-4fb9-80c1-d19d64a5e619.png" alt="image.png"></p><ol start="2"><li>曲面简化：是指将一个模型的面合理的合成更少的面，从而降低模型精度，为特定情形下提供使用(如LOD技术)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647748983265-8b44ee2a-5b3e-4a34-899b-1dcd4808489e.png" alt="image.png"></p><ol><li>所利用的一个方法叫做边坍缩，如上图所示就是将一条边的两个顶点合成为一个顶点。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647750229095-59d44ccb-afc0-4ad6-b63b-3ce1898d3647.png" alt="image.png"></p><pre><code>  1. 引入二次度量误差，即坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和。如果能够使得这个误差最小那么对整个模型样貌修改一定程度上也会较小。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647750314878-7043fad3-96ca-4218-8dbd-9cf84794f029.png" alt="image.png"></p><p><a name="As9Si"></a></p><h1 id="十二：Whitted-Style光线追踪原理详解及实现细节"><a href="#十二：Whitted-Style光线追踪原理详解及实现细节" class="headerlink" title="十二：Whitted-Style光线追踪原理详解及实现细节"></a>十二：Whitted-Style光线追踪原理详解及实现细节</h1><ol><li>Whitted-Style 光线追踪<ol><li>第一步 Ray Casting：从人眼或摄像机向近投影平面上的每一个像素点发射一条光线，判断与场景物体的交点，只去找最近的交点。接着连接该交点和光源，只要判断这条连线之间是否有物体存在就可以知道该交点是否在阴影之中（怎么样，是不是比shadow mapping那一套简单了许多）。紧接着利用Blinn-Phong模型对这个点进行局部光照模型计算，得到该像素的颜色，那么遍历所有近投影平面上的像素就能得到一张完整的图像。如果光线追踪仅仅是在第一步Ray Casting就停止的话，那么它的效果与局部光照模型是一样的，因此我们需要第二步，真正的考虑全局效果</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647755402630-38faecd1-cf61-4f82-b324-753c8f254540.png" alt="image.png"></p><ol start="2"><li>第二步 Recursive (Whitted-Style) Ray Tracing：求得后续交点，并将这些所有交点与光源连接，称这些线为shadow rays（因为可以用来检测阴影），计算这些所有点的局部光照模型的结果，将其<strong>按照光线能量权重累加</strong>(该做法与递归过程等价，读者可以看看伪代码思考一下)，最终得到近投影平面上该像素点的颜色</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647755923942-d90edb41-2846-4d0f-b059-261c8ead4fd1.png" alt="image.png"></p><ol start="3"><li>tips:<ol><li>整体过程是一个递归的过程，因此需要一定的递归终止条件，比如说允许的最大反射或折射次数为10。</li><li>光线在每次反射和折射之后都有能量损耗的，由系数决定，因此越往后的折射和反射光贡献的能量越小，这也是为什么在上文中提到根据光线能量权重求和。e.g. 反射系数为0.7，那么第一次反射折损30%，第二次反射折损1-（70%x70%），依次类推。</li><li>如果反射或折射光线没有碰撞到物体，一般直接返回一个背景色。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647756244862-9a915a0d-95ac-43fa-b858-8cafd037ac3f.png" alt="image.png"></p><ol start="2"><li>光线的表示方法：o+t*d，不展开了</li><li>光线与物体求交的方法<ol><li>光线与隐式曲面求交的方法</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647756605469-164a02c4-2eb9-4489-b9f2-1ccd7650c271.png" alt="image.png"></p><ol start="2"><li>光线与显式曲面求交的方法</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647756642974-3e291787-8745-43ed-953f-12b6a8372890.png" alt="image.png"></p><ol start="4"><li><p>反射与折射</p><ol><li>反射方向的计算（向量计算）</li><li>折射方向的计算（向量计算）</li><li>菲涅尔反射（一定条件下，没有折射项，光线全部反射）</li></ol></li><li><p>Note：whited-style光线追踪该如何考虑漫反射？</p><ul><li>在Blin-Phong模型中层提到过，漫反射是光线照射到粗糙物体表面从而发生向周围均匀反射光线的一种现象，反射的光线可以说是无数的！借鉴RayTracingInOneWeekend 里的做法，对于漫反射表面每次进行反射的时候，<strong>随机的选取物体表面向外半圆内的一个方向作为该次反射的方向</strong>，对其再像镜面反射及折射一样进行递归的光线追踪计算。</li><li>该方法更多算是path tracing，<strong>对于传统的whited-style光线追踪来说遇到漫反射表面会直接返回点着色值而不再递归下去</strong>。</li></ul></li></ol><p><a name="P7dwm"></a></p><h1 id="十三：加速光线追踪（KD-Tree-and-Bounding-Volume-Hierarchy）"><a href="#十三：加速光线追踪（KD-Tree-and-Bounding-Volume-Hierarchy）" class="headerlink" title="十三：加速光线追踪（KD-Tree and Bounding Volume Hierarchy）"></a>十三：加速光线追踪（KD-Tree and Bounding Volume Hierarchy）</h1><blockquote><p>避免与场景中所有的三角形面求交</p></blockquote><ol><li>轴对齐包围盒(Axis-Aligned Bounding Box)，轴对齐求交非常方便</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647758104059-00f7ec1e-a07e-4e6e-80f0-617fba84ad21.png" alt="image.png"></p><ol start="2"><li>均匀空间划分Uniform Spatial Partitions (Grids)<blockquote><p>为什么引入Grids?</p><ol><li>整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升</li><li>整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限</li></ol></blockquote><p>基于以上两点考虑，AABB并不应只局限于以物体模型为单位，可以更加精细的考虑到以三角面为单位。另外对于场景的许许多多包围盒来说应该要有一种数据结构将其统领起来。<br /><strong>因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，这就是接下来要考虑的问题关键！</strong></p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1649249477149-e85106a2-c243-453e-80d2-d7db0ede7c4c.png" alt="image.png"></p><ol><li>第一步对所要考虑的场景找一个包围盒：</li><li>第二步均匀划分这个大包围盒：</li><li>第三步在每个重叠小包围盒上存储物体模型信息</li><li>紧接着，根据光线的方向与判断出所有相交的方格(这一步可以利用bresenham算法)，倘若方格中存储有物体，再进一步与方格中的物体模型或是三角形面求交。</li></ol><ul><li>以上就是均匀空间划分的全部过程了，简单来说就是将空间划分为多个均匀的小的AABB，再根据光线方向找出相交grid(这一步并不需要判断所有方格，正如上文提示，可以用brenham类似的方法来做)，再判断grid中是否存储了模型信息，若有则进一步求交。</li><li>这种划分方法假设了找出相交方格要比直接判断与物体求交相对容易，因此划分方格数的多少也是性能的关键，方格太少，没有加速效果，方格太多，判断与方格的求交可能会拖累效率</li></ul><ol start="3"><li>KD-Tree空间划分，划分的位置由空间中三角面的分布决定，具体细节不展开<ol><li>若与父结点相交，便依次判断是否与子节点相交，到叶子节点时判断是否与物体相交</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647758901816-f902d442-7680-4430-9c37-059b3334b818.png" alt="image.png"></p><ol start="2"><li>优点：利用KD-Tree的结构来构建AABB的好处是倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程，在原始的纯粹的AABB之上更进一步提升了加速效率。</li><li>缺点：判断包围盒与三角面的是否相交较难，因此划分的过程不是那么想象的简单，其次同一个三角面可能被不同的包围盒同时占有，这两个不同包围盒内的叶节点会同时存储这一个三角形面</li><li>Bounding Volume Hierarchy（BVH）：与前几种方法最显著的区别就是，不再以空间作为划分依据，而是从对象的角度考虑，即三角形面<ol><li>第一步同样找出场景的整体包围盒作为根节点</li><li>第二步找到合适的划分点，将最大包围盒内的三角形面分为两部分，再分别重新就算新的包围盒</li><li>接下来与KD-Tree的建立类似，递归的对所有子空间重复该步骤</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647759757376-400fa400-426a-49ad-b255-44838f05fb00.png" alt="image.png"></p><ol start="4"><li>tips:<ol><li>每次划分一般选择最长的那一轴划分，假设是x轴，那么划分点选择所有三角面的重心坐标在x坐标上的中位数进行划分，如此便能保证划分的三角形左右两边三角形数量尽可能差不多，当然也就使得树形结构建立的更加平衡，深度更小，平均搜索次数更少，提高了效率。</li><li>与KD-Tree一样，中间节点不存储物体三角面信息，只在叶节点中存储，终止条件可设定为当前包围盒内三角形数量足够少 （e.g. 5个）</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647760171236-d61518bb-f215-466c-a501-f0e02cf728e5.png" alt="image.png"></p><p><a name="SBBeo"></a></p><h1 id="十四：基于物理渲染的基础知识-辐射度量学，BRDF和渲染方程"><a href="#十四：基于物理渲染的基础知识-辐射度量学，BRDF和渲染方程" class="headerlink" title="十四：基于物理渲染的基础知识(辐射度量学，BRDF和渲染方程)"></a>十四：基于物理渲染的基础知识(辐射度量学，BRDF和渲染方程)</h1><blockquote><p>为什么引入辐射度量学</p><ol><li>whited-style光线追踪并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色</li><li>在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的</li></ol></blockquote><p><strong>辐射能量(Radiant energy)，辐射通量(Radiant flux)，辐射强度(Radiant intensity)，irradiance，radiance</strong></p><ol><li>辐射能量(Radiant energy)和辐射通量(Radiant flux)<ol><li>就是辐射出来的电磁能量，单位为焦耳。可以用物理当中的做功的大小来进行类比。</li><li>所谓辐射通量或者说辐射功率，其实就是在辐射能量的基础之上除以时间，也就是单位时间的能量。同样也可以用物理当中的功率来进行类比。（比如灯泡功率）</li></ol></li><li>辐射强度(Radiant intensity)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647773017164-9079cb19-f4bf-4ab2-bce4-4774e7bfa5a8.png" alt="image.png"></p><ol><li><p>Radiant intensity：一句话来说就是从光源发出的每单位立体角上的<strong>功率</strong></p><blockquote><p><strong>微分立体角</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647777135112-90e77857-0e09-4876-af00-f0b8a6fc10df.png" alt="image.png"></p></blockquote></li><li><p>irradiance：是指<strong>每单位照射面积</strong>所接收到的power</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647777404007-65bef42c-8eac-4823-9441-c21b49c9c9bd.png" alt="image.png"></p><ol start="3"><li>radiance：就是指每单位立体角，每单位垂直面积的功率，直观来看的话，很像是Intensity和irradiance的结合。它同时指定了光的方向与照射到的表面所接受到的亮度。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647774497665-3723594f-4807-4315-854e-94927264ee64.png" alt="image.png"></p><ol start="3"><li>双向反射分布函数(BRDF)：直观的理解，不同物体表面材质自然会把一定方向上的入射亮度（dE(wi)），反射到不同的方向的光线上（dLr(wr)）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647776171079-5ba54d26-e6b8-4040-91a2-4e0aeac939ba.png" alt="image.png"></p><ul><li><strong>定义</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647776219429-7cdb84c0-e3cf-401b-bb46-b9b4e2f9ac52.png" alt="image.png"></p><ul><li>入射光线的radiance不仅仅是光源所造成，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点p，而其他物体上的反射光线的radiance依然也是这么个情况，没错！这与whitted-style当中的光线追踪过程十分类似，也是一个递归的过程。所以说想要解这样一个方程还是比较难的。</li></ul><ol start="4"><li>渲染方程及其物理含义解释：渲染方程知识在反射方程的基础之上添加了一个<strong>自发光项</strong>(Emission term)，从而使得反射方程更加的general：</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647776385382-d74c7286-2d36-4f95-b2b5-0aaf7930e9b3.png" alt="image.png"></p><ul><li>面光源就相当于无穷多个点光源的集合，只需要对 面光源所在的立体角范围进行积分，并且能够确定不同立体角方向的面光源的入射光radiance即可。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647778032056-23dce27c-ab55-495e-b29e-c50e6a647799.png" alt="image.png"></p><ul><li>那么更进一步的，再在场景当中加入其它物体，使得物体之间发生光线交互之后是什么情况呢：如上图所示，可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647778051915-85506c89-373d-47c9-aa93-c5ab6a37e249.png" alt="image.png"></p><ul><li>经过一系列推导，K代表弹射次数，次数越多越接近真实图片效果,趋近收敛</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647778268276-f4e3270c-b775-4c51-8ccc-920470620031.png" alt="image.png"><br><a name="SHddF"></a></p><h1 id="十五：基于物理的渲染-蒙特卡洛路径追踪"><a href="#十五：基于物理的渲染-蒙特卡洛路径追踪" class="headerlink" title="十五：基于物理的渲染(蒙特卡洛路径追踪)"></a>十五：基于物理的渲染(蒙特卡洛路径追踪)</h1><ol><li>蒙特卡洛积分(Monte Carlo Integration)：<strong>对函数值进行多次采样求均值作为积分值的近似，是一种无偏估计。</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647778827881-faa105b3-d8cc-47fa-8f3f-2d1af8ab9880.png" alt="image.png"></p><ul><li>若均匀采样，就和黎曼积分几乎一致；蒙特卡洛积分可以自定义分布（概率密度函数）来采样。</li><li>分布函数与f(x)形状相似是效果最好的</li></ul><ol start="2"><li>蒙特卡洛路径追踪(Monte Carlo Path Tracing)<blockquote><p>回顾一下渲染方程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647779207857-d4f1f6d5-d4cf-4d7e-b1d7-e04aa2bd7e9b.png" alt="image.png"><br>解方程的两个难点：1、积分的计算2、递归形式<br>注：后续计算中舍弃了自发光项，方便计算</p></blockquote><ol><li>从具体例子出发，首先仅仅考虑直接光照（光线直接照射到渲染点然后弹射到摄像机）：</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647780300676-a19be1af-1047-4795-adc8-d46bf6af43da.png" alt="image.png"></p><ol start="2"><li>然后考虑间接光照</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647780324901-7093778a-ca98-428f-96b3-26af3e04c598.png" alt="image.png"></p><pre><code>  1. 显然这是一个类似光线追踪的递归过程，**不同在于**该方法通过对光线方向的采样从而找出一条条可行的路径，这也正是为什么叫路径追踪的原因</code></pre><blockquote><p>路径追踪算法是基于蒙特卡洛采样算法的光线渲染方法，其核心思想与光线追踪算法一致，也是让光线从相机出发寻找光源，但具体做法是：<br>从相机平面的每一个像素点发射出多条光线寻找光源，光线在与场景中物体相交，发生反射时，按照预先设定的概率分布函数从半球面选择一个方向出射，并按照BRDF函数分配出射光线的能量分布。其余部分与光线追踪一致。</p></blockquote><pre><code>  2. 原本是在p点采样出N条弹射光线，但为了防止光线数量爆炸，每次弹射只采样一个方向，N=1</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647780972406-94e60674-d774-4b7e-b38a-aa1dd9455d71.png" alt="image.png"></p><pre><code>  3. 但采样一个方向会使结果非常noisy，解决方案：一个像素采样多条光线</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647781200575-2ca4cdcd-ffc1-40e7-85fd-94a7f721180a.png" alt="image.png"></p><ol start="3"><li>采用俄罗斯轮盘赌的方式设定递归出口</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647781347156-0b6d9d55-f88d-4aa8-92ee-81e2a4c45a08.png" alt="image.png"></p><ol start="4"><li>算法至此还存在一个问题，效率低下，因为<strong>在计算直接光照时</strong>，发射出的光线如果均匀采样，很难hit光源。当光源较小时，这个现象更加明显，大量采样的光线都被浪费了。<ol><li>解决方案：在计算直接光照的时候改进为<strong>直接对光源进行采样</strong></li><li>假设光源的面积为A，那么对光源进行采样的 pdf &#x3D; 1 &#x2F; A，且需要找到dA与dwi的转换关系</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647781794410-91be1aea-e421-4dfc-a61f-434b5aa0fc6f.png" alt="image.png"></p><ol start="5"><li>伪代码（每次进入shade函数都要对光源采样吗？此处得再看一下GAMES101的作业）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647781862858-7b183d58-ed5d-429d-8587-bec7db1a4562.png" alt="image.png"></p><ol start="6"><li>tips:计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡，该做法也很简单，只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647781948852-3a5c3d0a-ca8b-447c-95d4-6200e874e830.png" alt="image.png"></p><p><a name="YzpCr"></a></p><h1 id="十六：照相机与透镜"><a href="#十六：照相机与透镜" class="headerlink" title="十六：照相机与透镜"></a>十六：照相机与透镜</h1><ol><li>照相机主要部分<ol><li>透镜</li><li>快门</li><li>传感器（相当于胶片）</li></ol></li><li>小孔成像与视场(FOV)<ol><li>fov：焦距与传感器大小都对其有影响</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647846198174-79ebb64f-f0ba-4a18-8356-87da1389c174.png" alt="image.png"></p><ol start="3"><li>曝光(Exposure)：在第一章中我们提到传感器上接受到的是irradiance，也就是每单位面积所接受到的光线功率，而曝光就是用时间乘上了这个irradiance，Exposure &#x3D; time x irradiance，从物理意以上来说就是真正的所接受到的能量(Energy)。<ol><li>曝光有三个量控制：<ol><li>快门速度(Shutter speed)，快门打开时间越长，进光时间越长，进光量自然越多。快门打开时间长会产生动态模糊。</li><li>光圈大小(Aperture size)，描述此项的数值称为f-stop，直观理解如果光圈越大，即遮挡的光越少那么曝光的程度就会越高。</li><li>感光度(ISO gain)，对于感光度可以简单理解为对最终的图像值乘上了一个倍数。</li></ol></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647846511099-97ed9489-d058-47d1-8a72-b0694fcb9b84.png" alt="image.png"></p><p>](<a href="https://blog.csdn.net/qq_38065509/article/details/106714036">https://blog.csdn.net/qq_38065509/article/details/106714036</a>)</p><ol start="4"><li>景深(Depth of Field)<ol><li>当一个传感器平面<strong>不在一个物体真正精确的成像平面之上时</strong>(即之前所提到到像距z i 的平面)，便会出现模糊。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647847072063-9060ba8a-3800-43a6-b14a-068d1d63f501.png" alt="image.png"></p><ol start="2"><li>景深模糊程度可以接受的距离，再此距离之外可能很模糊</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647847394448-bb4dde39-96e9-44d2-9ae5-63a96d172f0d.png" alt="image.png"></p><ol start="5"><li>关于如何在光线追踪中实现景深，只需要简单的模拟透镜的光线传播即可</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22924277/1647847600937-568087f3-d87c-4edd-83e7-58df6b799df0.png" alt="image.png"><br><a name="XHdJt"></a></p><h1 id="十七：基于物理的渲染：微平面理论-Cook-Torrance-BRDF推导"><a href="#十七：基于物理的渲染：微平面理论-Cook-Torrance-BRDF推导" class="headerlink" title="十七：基于物理的渲染：微平面理论(Cook-Torrance BRDF推导)"></a>十七：基于物理的渲染：微平面理论(Cook-Torrance BRDF推导)</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基于《GAMES101》课程&lt;br&gt;整理自CSDN某位博主&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a name=&quot;bMMtC&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一：基础变换矩阵总结-缩放，旋转，位移&quot;&gt;&lt;a href=&quot;#一：基础变换矩阵总</summary>
      
    
    
    
    
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++并发线程实战》杂记</title>
    <link href="http://example.com/2022/09/03/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E6%9D%82%E8%AE%B0/"/>
    <id>http://example.com/2022/09/03/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E6%9D%82%E8%AE%B0/</id>
    <published>2022-09-03T12:06:32.000Z</published>
    <updated>2022-09-05T15:25:30.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2章-线程管理"><a href="#第2章-线程管理" class="headerlink" title="第2章 线程管理"></a>第2章 线程管理</h1><p>线程以一个函数作为入口，函数执行完线程也就结束了。</p><p><strong>类型：</strong>启动了线程之后要明确是加入式(.join)还是分离式(.detach)。在一个函数执行完后，会收回函数内所执行的线程，所以可通过.join()来阻塞，或通过.detach()来分离，通常称分离线程为守护线程。两者使用前都需要通过.joinable()来检查。文档编辑器打开的多个文档就是分离线程。</p><p><strong>向线程函数传参：</strong>实例化线程时括号里函数名后面加上参数即可。注意std::thread的构造函数已经实现好，传的值都是拷贝，所以传引用要使用ref，后续再深入了解吧。</p><p><strong>转移线程所有权</strong>：可使用std::move()。</p><p><strong>运行时决定线程数量</strong>：书中实现了一个并行版本的accumulate函数，考虑了系统允许的线程最大数量。</p><p><strong>标识线程</strong>：get_id()。可以通过判断ID来区分是不是主线程，从而确定要做的任务。</p><h1 id="第3章-线程间共享数据"><a href="#第3章-线程间共享数据" class="headerlink" title="第3章 线程间共享数据"></a>第3章 线程间共享数据</h1><p><strong>共享数据带来的问题</strong>：修改数据时会遇到此问题，条件竞争。并发地修改双向链表会出错，并发地向队列添加元素不会。</p><p><u><em>注：RAII机制是一种编程方式，一般指对现有的数据结构进行封装，在析构函数里进行释放、线程join，等等。（本来设置了斜体但网页中不显示。。。有空问问别人咋整）</em></u></p><p><strong>使用互斥量保护共享数据</strong>：</p><ol><li>C++中使用互斥量：C++中通过实例化 std::mutex 创建互斥量实例，通过成员函数lock()对互斥量上锁，unlock() 进行解锁。也可用std::lock_guard。提防后门：当其中一个成员函数返回的是保护数据的指针或引用时，会破坏数据。（因为暂时不知锁的具体实现方式，所以先不深究）</li><li>用代码保护共享数据：给了一个破坏数据的例子。</li><li>定位接口间的条件竞争：有些接口的实现是无锁编程，用stack举了例子。实现了一个线程安全的stack，没看懂，以后再看。</li><li>死锁的问题描述及解决方案：</li></ol><p>产生的四个必要条件：</p><p><strong>互斥：</strong>资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</p><p><strong>占有并等待：</strong>一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</p><p><strong>非抢占：</strong>资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</p><p><strong>循环等待：</strong>有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。</p><p>5. </p><p><strong>看着实在费力，以后闲下来了再看吧。先去看通用的OS了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第2章-线程管理&quot;&gt;&lt;a href=&quot;#第2章-线程管理&quot; class=&quot;headerlink&quot; title=&quot;第2章 线程管理&quot;&gt;&lt;/a&gt;第2章 线程管理&lt;/h1&gt;&lt;p&gt;线程以一个函数作为入口，函数执行完线程也就结束了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型：&lt;/</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客教程推荐</title>
    <link href="http://example.com/2022/09/03/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%E6%8E%A8%E8%8D%90/"/>
    <id>http://example.com/2022/09/03/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%E6%8E%A8%E8%8D%90/</id>
    <published>2022-09-03T09:58:12.000Z</published>
    <updated>2022-09-03T10:07:59.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/v2-d4c1239e75c02e8482c22017a6c8d407_1440w.jpg"></p><blockquote><p>本人博客搭建就是用的这两个教程，内容很详细靠谱</p></blockquote><p><strong>使用说明：先看教程1来搭博客，里面涉及到图床的部分可以先略过，搭好之后可以看教程2</strong></p><ol><li>知乎：“GitHub+Hexo 搭建个人网站详细教程”</li></ol><p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p><ol start="2"><li>知乎：“使用Github+picGo搭建图床，保姆级教程来了”</li></ol><p><a href="https://zhuanlan.zhihu.com/p/489236769">https://zhuanlan.zhihu.com/p/489236769</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/v2-d4c1239e75c02e8482c22017a6c8d407_1440w.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本人博客搭</summary>
      
    
    
    
    
    <category term="好文推荐" scheme="http://example.com/tags/%E5%A5%BD%E6%96%87%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/2022/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-09-03T08:15:34.000Z</published>
    <updated>2022-09-03T09:19:56.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、十大排序"><a href="#一、十大排序" class="headerlink" title="一、十大排序"></a>一、十大排序</h1><h2 id="1、冒泡排序-O-n2-稳定"><a href="#1、冒泡排序-O-n2-稳定" class="headerlink" title="1、冒泡排序 O(n2) 稳定"></a>1、冒泡排序 <strong>O(n2) 稳定</strong></h2><p>以构造递增数组为例<br>双层循环，从前往后依次比较两个相邻元素，若前一个大于后一个，就交换。让数组从后往前，每一个当前元素都是剩余元素最大的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++ )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; len - <span class="number">1</span> - i ; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、选择排序-O-n2-不稳定"><a href="#2、选择排序-O-n2-不稳定" class="headerlink" title="2、选择排序 O(n2) 不稳定"></a>2、选择排序 <strong>O(n2) 不稳定</strong></h2><p>双层循环，每一轮记录最小元素的下标，并交换到循环开始的位置</p><h2 id="3、插入排序-O-n2-稳定"><a href="#3、插入排序-O-n2-稳定" class="headerlink" title="3、插入排序 O(n2) 稳定"></a>3、插入排序 <strong>O(n2) 稳定</strong></h2><p>类似于整理手里的扑克牌<br>从前往后依次取出，记为value，并往前比较，如果大于value就往后移；直到遇到小于value的，就插入在那里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr=&#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> value = arr[i];</span><br><span class="line">    <span class="type">int</span> j ;<span class="comment">//插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; value) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];<span class="comment">//移动数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>] = value; <span class="comment">//插入数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(arr);</span><br></pre></td></tr></table></figure><h2 id="4、希尔排序-不稳定"><a href="#4、希尔排序-不稳定" class="headerlink" title="4、希尔排序 不稳定"></a>4、希尔排序 不<strong>稳定</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif"></p><ul><li>插入排序对于大规模的乱序数组的时候效率是比较慢的，因为它每次只能将数据移动一位，希尔排序为了加快插入的速度，让数据移动的时候可以实现跳跃移动，节省了一部分的时间开支。</li><li>对每个分组采用插入排序</li><li>起始区间一般选择二分之一到三分之一附近</li><li>当区间为 1 的时候，它使用的排序方式就是插入排序。</li></ul><h2 id="5、归并排序-O-log-n-稳定"><a href="#5、归并排序-O-log-n-稳定" class="headerlink" title="5、归并排序 O(log n) 稳定"></a>5、归并排序 O(log n) <strong>稳定</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650002894967-756bdac0-b0e5-49a6-9c1f-b8e686f25d1d.jpeg"></p><ul><li><p>需要一个辅助数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums,tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//划分</span></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//分成两份后分别的结果相加</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(l,m,nums,tmp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(m+<span class="number">1</span>,r,nums,tmp);</span><br><span class="line">    <span class="comment">//将[l,r]用一个数组保存合并之前的模样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对[l,r]中的[l,m]、[m+1,r]开始合并</span></span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">int</span> j = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m及其左边元素合并完毕,把右边剩下的放入合并后的数组</span></span><br><span class="line">        <span class="keyword">if</span>(i==m+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = tmp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//m+1及其右边元素合并完毕,把左边剩下的放入合并后的数组 或者 左边数组的元素小于等于右边,将左边数组的元素放入结果数组中,并让索引i加1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j==r+<span class="number">1</span> || tmp[i]&lt;=tmp[j])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = tmp[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右边数组的元素小于左边,将右边数组的元素其放入结果数组中,并让索引j加1</span></span><br><span class="line">        <span class="comment">//并且此时左边数组中的从i到m的所有数都是大于tmp[j]的(因为m左右的数组都是已经排好序的，第15行代码的功劳)</span></span><br><span class="line">        <span class="comment">//即此时有m-i+1个逆序对，加到res上即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//即if(tmp[i]&gt;tmp[j])这种情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = tmp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>merge 方法中只有一个 for 循环，直接就可以得出每次合并的时间复杂度为 O(n) ，而分解数组每次对半切割，属于对数时间 O(log n) ，合起来等于 O(log2n) ，也就是说，总的时间复杂度为 O(nlogn) 。</p></li></ul><h2 id="6、快速排序-O-nlogn-不稳定"><a href="#6、快速排序-O-nlogn-不稳定" class="headerlink" title="6、快速排序 O(nlogn) 不稳定"></a>6、快速排序 O(nlogn) 不<strong>稳定</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对arr数组进行排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分操作（以 arr[l] 作为基准数）</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;<span class="comment">//最后 i==j</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[l]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">recur</span>(arr, l, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">recur</span>(arr, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、堆排序-O-nlogn-不稳定"><a href="#7、堆排序-O-nlogn-不稳定" class="headerlink" title="7、堆排序 O(nlogn) 不稳定"></a>7、堆排序 O(nlogn) 不<strong>稳定</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 构建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    <span class="built_in">sink</span>(nums,i,len);</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="comment">//将堆顶元素与末位元素调换</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[i]);</span><br><span class="line">    <span class="comment">//数组长度-1 隐藏堆尾元素</span></span><br><span class="line">    len--;</span><br><span class="line">    <span class="comment">//将堆顶元素下沉 目的是将最大的元素浮到堆顶来</span></span><br><span class="line">    <span class="built_in">sink</span>(nums, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> i,<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> now=i;</span><br><span class="line">    <span class="comment">//下沉左边</span></span><br><span class="line">    <span class="keyword">if</span> (left&lt;len &amp;&amp; nums[left]&gt;nums[now]) now=left;</span><br><span class="line">    <span class="comment">//下沉右边</span></span><br><span class="line">    <span class="keyword">if</span> (right&lt;len &amp;&amp; nums[right]&gt;nums[now]) now=right;</span><br><span class="line">    <span class="comment">//如果下标不相等 证明调换过了</span></span><br><span class="line">    <span class="keyword">if</span> (now!=i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[now]);</span><br><span class="line">        <span class="built_in">sink</span>(nums,now,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、计数排序-≈O-n-稳定"><a href="#8、计数排序-≈O-n-稳定" class="headerlink" title="8、计数排序 ≈O(n) 稳定"></a>8、计数排序 ≈O(n) <strong>稳定</strong></h2><p>以[ 3，5，8，2，5，4 ]这组数字来演示。<br>首先，我们找到这组数字中最大的数，也就是 8，创建一个最大下标为 8 的空数组 arr 。<br>遍历数据，将数据的出现次数填入arr中对应的下标位置中。<br>最后遍历 arr ，将数据依次取出即可。</p><ul><li>计数排序只适用于正整数并且取值范围相差不大的数组排序使用，它的排序的速度是非常可观的。</li></ul><h2 id="9、桶排序-O-n-稳定"><a href="#9、桶排序-O-n-稳定" class="headerlink" title="9、桶排序 O(n) 稳定"></a>9、桶排序 O(n) <strong>稳定</strong></h2><p>桶排序可以看成是计数排序的升级版，它将要排的数据分到多个有序的桶里，每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序。<br>在额外空间充足的情况下，尽量增大桶的数量，极限情况下每个桶只有一个数据时，或者是每只桶只装一个值时，完全避开了桶内排序的操作，桶排序的最好时间复杂度就能够达到 O(n)。</p><h2 id="10、基数排序-稳定"><a href="#10、基数排序-稳定" class="headerlink" title="10、基数排序 稳定"></a>10、基数排序 <strong>稳定</strong></h2><p>基数排序是一种非比较型整数排序算法，其原理是将数据按位数切割成不同的数字，然后按每个位数分别比较。<br>需要创建十个桶来对应每一位0~9的是个数字<br>先排个位数，根据个位数的值将数据放到对应下标值的桶中。接下来排十位数、百位数。<br>最后取出的就是有序数组。</p><h2 id="附录1：各种排序算法的稳定性"><a href="#附录1：各种排序算法的稳定性" class="headerlink" title="附录1：各种排序算法的稳定性"></a>附录1：各种排序算法的稳定性</h2><p>稳定排序 ：冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序<br>不稳定排序 ：快速排序、希尔排序、选择排序、堆排序</p><h2 id="附录2：各种排序算法的特点总览"><a href="#附录2：各种排序算法的特点总览" class="headerlink" title="附录2：各种排序算法的特点总览"></a>附录2：各种排序算法的特点总览</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650006879516-3f0b4659-29cb-4183-8615-c6dd75ca8dea.png"></p><h1 id="二、洗牌算法-（打乱）"><a href="#二、洗牌算法-（打乱）" class="headerlink" title="二、洗牌算法 （打乱）"></a>二、洗牌算法 （打乱）</h1><h2 id="1、抽牌并拿出来放在另一个数组开头，开头不断后推"><a href="#1、抽牌并拿出来放在另一个数组开头，开头不断后推" class="headerlink" title="1、抽牌并拿出来放在另一个数组开头，开头不断后推"></a>1、抽牌并拿出来放在另一个数组开头，开头不断后推</h2><p>基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，使用了vector的erase。</p><ol><li>初始化原始数组和<strong>辅助数组</strong>，原始数组长度为n(已知)；</li><li>从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）；</li><li>从剩下的k个数中把第p个数取出；</li><li>重复步骤2和3直到数字全部取完；</li><li>从步骤3取出的数字序列便是一个打乱了的数列。</li></ol><h2 id="2、抽牌并与末尾的元素交换，末尾不断前推"><a href="#2、抽牌并与末尾的元素交换，末尾不断前推" class="headerlink" title="2、抽牌并与末尾的元素交换，末尾不断前推"></a>2、抽牌并与末尾的元素交换，末尾不断前推</h2><p>对1的改进，<strong>省去了额外O(n)的空间</strong>。基本思想类似，每次从未处理的数据中随机取出一个数字，然后把该数字与数组的尾部交换，即数组尾部存放的是已经处理过的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Knuth_Durstenfeld_Shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=arr.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="built_in">rand</span>()%(i+<span class="number">1</span>)],arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于arr[i],洗牌后在第n-1个位置的概率是1&#x2F;n（第一次交换的随机数为i）<br>在n-2个位置概率是[(n-1)&#x2F;n] * [1&#x2F;(n-1)] &#x3D; 1&#x2F;n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i&#x3D;n-1，第一交换arr[n-1]会被换到一个随机的位置））<br>在第n-k个位置的概率是[(n-1)&#x2F;n] * [(n-2)&#x2F;(n-1)] <em>…</em> [(n-k+1)&#x2F;(n-k+2)] *[1&#x2F;(n-k+1)] &#x3D; 1&#x2F;n<br>（第一个随机数不要为i，第二次不为arr[i]所在的位置(随着交换有可能会变)……第n-k次为arr[i]所在的位置）.</p><h2 id="3、从前往后，可适应动态增加"><a href="#3、从前往后，可适应动态增加" class="headerlink" title="3、从前往后，可适应动态增加"></a>3、从前往后，可适应动态增加</h2><p>基本思想是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k），这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">rand</span>()%(i+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(res[i],res[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明如下：<br>原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1&#x2F;i) * [i&#x2F;(i+1)] * [(i+1)&#x2F;(i+2)] <em>…</em> [(n-1)&#x2F;n] &#x3D; 1&#x2F;n，（即第i次刚好随机放到了该位置，在后面的n-i 次选择中该数字不被选中）。<br>原数组的第 i 个元素（随机到的数）在新数组的 i+1 （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1&#x2F;k) * [k&#x2F;(k+1)] * [(k+1)&#x2F;(k+2)] <em>…</em> [(n-1)&#x2F;n] &#x3D; 1&#x2F;n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。</p><h1 id="三、循环队列"><a href="#三、循环队列" class="headerlink" title="三、循环队列"></a>三、循环队列</h1><p>用数组来储存，初始设置容量MAXQSIZE<br>队列长度：Q.rear-Q.front；<br>队头元素：Q.base[Q.front]；<br>队尾元素：Q.base[Q.rear-1]；<br>即rear指向的是空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 添加元素</span><br><span class="line"><span class="function">status <span class="title">EnQueue</span><span class="params">(SqQueue *q,QElemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入到队尾</span></span><br><span class="line">    <span class="keyword">if</span>((q-&gt;rear+<span class="number">1</span>)%MAXQSIZE==q-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;base[q-&gt;rear]=e;</span><br><span class="line">    q-&gt;rear=(q-&gt;rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 删除元素</span><br><span class="line"><span class="function">status <span class="title">EnQueue</span><span class="params">(SqQueue *q,QElemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(<span class="keyword">this</span>)) <span class="comment">// 以后再改</span></span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> item = <span class="keyword">this</span>.array[<span class="keyword">this</span>.front]; </span><br><span class="line">    <span class="keyword">this</span>.front = (<span class="keyword">this</span>.front + <span class="number">1</span>)%<span class="keyword">this</span>.capacity; </span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> item; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> 获取队列长度</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;rear-q-&gt;front+MAXQSIZE)%MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、哈希表"><a href="#四、哈希表" class="headerlink" title="四、哈希表"></a>四、哈希表</h1><h2 id="1、哈希函数的构造方法"><a href="#1、哈希函数的构造方法" class="headerlink" title="1、哈希函数的构造方法"></a>1、哈希函数的构造方法</h2><ol><li>直接定制：弄一个线性函数</li><li>数字分析：分析key中的全体数据，并从中提取分布均匀的若干位或他们的组合构成全体</li><li>平方取中法：如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。</li><li>折叠法：如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为hash地址</li><li>除留余数法：用的较多</li></ol><p>H（key）&#x3D;key MOD p （p&lt;&#x3D;m m为表长）<br>p应为不大于m的质数或是不含20以下的质因子的合数，这样可以减少地址的重复（冲突）</p><ol start="6"><li>随机数法：H（key） &#x3D;Random（key） 取关键字的随机函数值为它的散列地址</li></ol><h2 id="2、哈希冲突的解决方案"><a href="#2、哈希冲突的解决方案" class="headerlink" title="2、哈希冲突的解决方案"></a>2、哈希冲突的解决方案</h2><ol><li>开放定制法<ol><li>线性探测再散列</li><li>平方探测再散列</li><li>随机探测再散列</li></ol></li><li>链地址法：每个地址维护一个链表，冲突就后延</li><li>公共溢出区法：建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况</li><li>再散列法：准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……</li></ol><h2 id="3、哈希表的查找效率"><a href="#3、哈希表的查找效率" class="headerlink" title="3、哈希表的查找效率"></a>3、哈希表的查找效率</h2><p>装载因子 α&#x3D;n&#x2F;m(n表示实际装载数据长度 m为表长)<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650037230644-da9b98de-69a1-4a2e-af1b-7d65e6084b31.png"></p><h2 id="4、哈希表的删除"><a href="#4、哈希表的删除" class="headerlink" title="4、哈希表的删除"></a>4、哈希表的删除</h2><p>首先链地址法是可以直接删除元素的，但是开放定址法是不行的，拿前面的双探测再散列来说，假如我们删除了元素1，将其位置置空，那 23就永远找不到了。正确做法应该是删除之后置入一个原来不存在的数据，比如-1<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650271022196-22c0ab00-906a-4aa4-9724-8dfe3ace1755.png"></p><h1 id="五、树"><a href="#五、树" class="headerlink" title="五、树"></a>五、树</h1><h2 id="1、二叉树的遍历"><a href="#1、二叉树的遍历" class="headerlink" title="1、二叉树的遍历"></a>1、二叉树的遍历</h2><ul><li>先序和中序代码中，变化的只有访问元素的位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>非递归先序遍历</span><br><span class="line"><span class="comment">// 思路：其实一般要想通过非递归的方式实现递归方式的算法，一般都是要使用栈。</span></span><br><span class="line"><span class="comment">// 首先我们的循环条件是：结点不为空或者栈不为空。然后是先把根结点加入桟中，</span></span><br><span class="line"><span class="comment">// 然后，遍历左子树，当左子树遍历完后，栈顶元素为刚刚的根结点，</span></span><br><span class="line"><span class="comment">// 然后，让根结点出栈，遍历右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderTraverse_no_recursive</span><span class="params">(Tree_Node * T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;Tree_Node*&gt; s;</span><br><span class="line">    Tree_Node * p=T;</span><br><span class="line">        <span class="comment">//栈不为空或者T不为空时，循环继续</span></span><br><span class="line">    <span class="keyword">while</span>(p || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p); <span class="comment">//根结点入栈</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">//访问根结点</span></span><br><span class="line">            p=p-&gt;left; <span class="comment">//先遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>(); <span class="comment">//根结点出栈</span></span><br><span class="line">            s.<span class="built_in">pop</span>();   <span class="comment">//</span></span><br><span class="line">            p=p-&gt;right;<span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 非递归中序遍历二叉树</span><br><span class="line"><span class="comment">// 思路：T是要遍历树的根指针，中序遍历要求在遍历完左子树后，访问根，再遍历右子树。 </span></span><br><span class="line"><span class="comment">// 先将T入栈，遍历左子树；遍历完左子树返回时，栈顶元素应为T，出栈，</span></span><br><span class="line"><span class="comment">// 访问T-&gt;data，再中序遍历T的右子树。 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverse_recursive</span><span class="params">(Tree_Node * T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;Tree_Node*&gt; s;</span><br><span class="line">    Tree_Node * p=T;</span><br><span class="line">        <span class="comment">//栈不为空或者T不为空时，循环继续</span></span><br><span class="line">    <span class="keyword">while</span>(p || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p); <span class="comment">//根结点入栈</span></span><br><span class="line">            p=p-&gt;left; <span class="comment">//先遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>(); <span class="comment">//根结点出栈，也就是把之前的左节点提出来</span></span><br><span class="line">            s.<span class="built_in">pop</span>();   <span class="comment">//</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">//访问根结点</span></span><br><span class="line">            p=p-&gt;right;<span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 后序遍历有点复杂了，不想看，下面放个链接</span><br><span class="line">https:<span class="comment">//blog.csdn.net/qq_35644234/article/details/53013738</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1、AVL树-平衡二叉查找树"><a href="#1、AVL树-平衡二叉查找树" class="headerlink" title="1、AVL树 平衡二叉查找树"></a>1、AVL树 平衡二叉查找树</h2><h2 id="2、B树-平衡多路查找树"><a href="#2、B树-平衡多路查找树" class="headerlink" title="2、B树 平衡多路查找树"></a>2、B树 平衡多路查找树</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650096843736-e58e55ec-a4f3-48b7-a979-530d24c5c2fc.png"><br><strong>特点：</strong></p><ol><li>定义阶数m</li><li>每个结点最多有m-1个关键字</li><li><strong>根结点</strong>最少可以只有1个关键字。</li><li><strong>非根结点</strong>至少有int(m&#x2F;2)个关键字。</li><li>每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</li></ol><p><strong>查询流程：</strong><br>如上图我要从上图中找到E字母，查找流程如下<br>（1）获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；<br>（2）拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；<br>（3）拿到E和F，因为E&#x3D;E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p><h2 id="3、B-树-B树的升级版"><a href="#3、B-树-B树的升级版" class="headerlink" title="3、B+树 B树的升级版"></a>3、B+树 B树的升级版</h2><p><strong>特点：</strong></p><ol><li>保存了两个指针，一个指向根节点，一个指向第一个叶子节点</li><li>所有的数据都在叶子节点，内部节点只储存索引</li><li>叶子节点形成了一个有序链表</li><li>非叶子节点的子节点数&#x3D;关键字数</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650100844216-2569d881-c53a-41ef-9df5-07f45fb4d10d.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650100741524-fdb5cd7d-4967-4ef2-b372-e565017a13c7.png"></p><h3 id="B树与B-树的一些区别："><a href="#B树与B-树的一些区别：" class="headerlink" title="B树与B+树的一些区别："></a>B树与B+树的一些区别：</h3><ol><li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li><li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ol><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h2 id="4、红黑树"><a href="#4、红黑树" class="headerlink" title="4、红黑树"></a>4、红黑树</h2><h1 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h1><h2 id="1、名词解释"><a href="#1、名词解释" class="headerlink" title="1、名词解释"></a>1、名词解释</h2><ul><li>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。在图中的数据元素，我们称之为顶点（Vertex），顶点集合有穷非空。在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li><li>图按照边的有无方向分为无向图和有向图。无向图由顶点和边组成，有向图由顶点和弧构成。弧有弧尾和弧头之分，带箭头一端为弧头。</li><li>图按照边或弧的多少分稀疏图和稠密图。如果图中的任意两个顶点之间都存在边叫做<strong>完全图</strong>，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。</li><li>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度。有向图顶点分为入度和出度。</li><li>图上的边或弧带有权则称为<strong>网</strong>。</li><li>图中顶点间存在路径，<strong>两顶点存在路径则说明是连通的</strong>，如果路径最终回到起始点则称为环，当中不重复的叫简单路径。若任意两顶点都是连通的，则图就是<strong>连通图</strong>，有向则称为<strong>强连通图</strong>。图中有子图，若子图极大连通则就是连通分量，有向的则称为强连通分量。</li><li>无向图中连通且n个顶点n-1条边称为<strong>生成树</strong>。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</li></ul><h2 id="2、图的存储结构"><a href="#2、图的存储结构" class="headerlink" title="2、图的存储结构"></a>2、图的存储结构</h2><h3 id="1-邻接矩阵（若是网就使用权值来代替元素）"><a href="#1-邻接矩阵（若是网就使用权值来代替元素）" class="headerlink" title="1.邻接矩阵（若是网就使用权值来代替元素）"></a>1.邻接矩阵（若是网就使用权值来代替元素）</h3><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122551576-43adbd85-7aed-4cca-ad07-2b49ef5fba26.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122376601-d0fcf4f9-9d85-4543-b26a-fee998aa52cb.png"></p><ul><li>优点：直观、容易理解，可以很容易的判断出任意两个顶点是否有边，最大的优点就是很容易计算出各个顶点的度。</li><li>缺点：当我们表示完全图的时候，邻接矩阵是最好的表示方法，但是对于稀疏矩阵，由于它边少，但是顶点多，这样就会造成空间的浪费。</li></ul><h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2.邻接表"></a>2.邻接表</h3><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122631497-3b5fb955-139a-468e-a0d3-12bfc1fab1e0.png"></p><ul><li>优点：对于稀疏图，邻接表比邻接矩阵更节约空间。</li><li>缺点：不容易判断两个顶点是有关系（边），顶点的出度容易，但是求入度需要遍历整个邻接表。</li></ul><h3 id="3-十字链表（有向图）"><a href="#3-十字链表（有向图）" class="headerlink" title="3.十字链表（有向图）"></a>3.十字链表（有向图）</h3><blockquote><p>邻接表对于我们计算顶点的<strong>入度</strong>是一个很麻烦的事情，而十字链表正好可以解决这个问题。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122854571-9521b933-b48d-4aea-8800-eda4f5833165.png"></p><h3 id="4-邻接多重表（无向图）-储存的是边"><a href="#4-邻接多重表（无向图）-储存的是边" class="headerlink" title="4.邻接多重表（无向图） 储存的是边"></a>4.邻接多重表（无向图） 储存的是边</h3><blockquote><p>邻接多重表是无向图的另一种链式存储结构。我们之前也说了使用邻接矩阵来存储图比较浪费空间，但是如果我们使用邻接表来存储图时，对于无向图又有一些不便的地方，例如删除边的时候。<br>其中，头结点的结构和邻接表一样，而表结点中就改变比较大了，其中mark为标志域，例如标志是否已经访问过，ivex和jvex代表边的两个顶点在顶点表中的下标，ilink指向下一个依附在顶点ivex的边，jlink指向下一个依附在顶点jvex的边，weight在网图的时候使用，代表该边的权重。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122927074-922ee49d-ac98-4e4e-a55c-384b19b4e4fd.png"></p><h2 id="3、图的遍历——BFS和DFS"><a href="#3、图的遍历——BFS和DFS" class="headerlink" title="3、图的遍历——BFS和DFS"></a>3、图的遍历——BFS和DFS</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649126768667-31b1a779-be79-4a23-9972-caafead765f3.png"></p><ol><li>DFS：使用邻接表，递归</li><li>BFS：也使用邻接表，队列</li></ol><ul><li>都需要一个一维数组visit来储存每个顶点是否被访问过</li></ul><h2 id="4、最小生成树"><a href="#4、最小生成树" class="headerlink" title="4、最小生成树"></a>4、最小生成树</h2><p>现在假设有一个很实际的问题：我们要在n个城市中建立一个通信网络，则连通这n个城市需要布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？<br>我们引入连通图来解决我们遇到的问题，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。<br>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：<strong>MST性质</strong>（假设N&#x3D;(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649128879149-b0df49ad-c73c-4475-907f-322eb6227ac5.png"></p><h3 id="1-普里姆算法—Prim算法"><a href="#1-普里姆算法—Prim算法" class="headerlink" title="1.普里姆算法—Prim算法"></a>1.普里姆算法—Prim算法</h3><h3 id="2-克鲁斯卡算法（一种贪心策略）"><a href="#2-克鲁斯卡算法（一种贪心策略）" class="headerlink" title="2.克鲁斯卡算法（一种贪心策略）"></a>2.克鲁斯卡算法（一种贪心策略）</h3><p><a href="https://blog.csdn.net/qq_35644234/article/details/59106779?spm=1001.2014.3001.5502">博客链接</a></p><h2 id="5、拓扑排序"><a href="#5、拓扑排序" class="headerlink" title="5、拓扑排序"></a>5、拓扑排序</h2><p>对一个有向<strong>无环</strong>图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。拓扑排序对应施工的流程图具有特别重要的作用，它可以决定哪些子工程必须要先执行，哪些子工程要在某些工程执行后才可以执行。<br>通常，我们把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网(Activity On Vertex network)，简称<strong>AOV网</strong>。<br>AOV网不应有环。<br><strong>算法实现：</strong>（使用<strong>邻接表</strong>来初始化、改变别的顶点的入度）</p><ol><li>在有向图中选一个没有前驱的顶点并且输出</li><li>从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）</li><li>重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的，因此，也可以通过拓扑排序来判断一个图是否有环。</li></ol><p><a href="https://blog.csdn.net/qq_35644234/article/details/60578189?spm=1001.2014.3001.5502">博客链接</a></p><h2 id="6、关键路径"><a href="#6、关键路径" class="headerlink" title="6、关键路径"></a>6、关键路径</h2><p><strong>AOE-网</strong>只是比AOV-网多了一个边的权重，而且AOV-网一般是设计一个庞大的工程各个子工程实施的先后顺序，而我们的AOE-网就是不仅仅关系整个工程中各个子工程的实施的先后顺序，同时也关系整个工程完成最短时间。<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649149699793-2f0e5ebb-51cd-4cb5-8e55-aff76a327859.png"></p><ol><li>事件（顶点）的最早发生时间：ve[k]正向推<br> . 事件（顶点）的最迟发生时间：vl[k]逆向推<br> . 活动（边）的最早发生时间：ee[i]ee[i]&#x3D;ve[j]<ol><li>只有顶点Vk代表的事件发生，活动ai才能开始，即活动ai的最早开始时间等于事件Vk的最早开始时间。<br>   活动（边）的最迟发生时间：el[i]el[i]&#x3D;vl[k]-a[ ]<em>(dut(&lt;j,k&gt;))</em></li><li>el[i]是指在不推迟整个工期的前提下，活动ai必须开始的最晚时间。若活动ai由有向边&lt;Vk, Vj&gt;表示，则ai的最晚开始时间要保证事件vj的最迟发生时间不拖后。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650273091022-ad21d927-fd19-42ba-8ff2-71c9095413b2.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649160701607-cce6569e-7d9b-4bd9-9ff1-ea83d8529385.png"><br><a href="https://blog.csdn.net/fu_jian_ping/article/details/88962697?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164914917516780261936274%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164914917516780261936274&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-88962697.142%5Ev5%5Epc_search_insert_es_download,157%5Ev4%5Enew_style&utm_term=%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84&spm=1018.2226.3001.4187">博客链接</a></p><h2 id="7、最短路径——迪杰斯特拉"><a href="#7、最短路径——迪杰斯特拉" class="headerlink" title="7、最短路径——迪杰斯特拉"></a>7、最短路径——迪杰斯特拉</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650467990251-a3db2a77-9da3-44c5-8fa1-ce3ff8fac5f6.png"></p><ul><li>使用邻接矩阵</li><li>贪心思想</li><li>解决单源最短路径问题</li><li>该算法复杂度为n^2,我们可以发现，如果边数远小于n^2,对此可以考虑用堆这种数据结构进行优化，取出最短路径的复杂度降为O(1)。每次调整的复杂度降为O（elogn）；e为该点的边数，所以复杂度降为O((m+n)logn)。</li></ul><p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_35644234&#x2F;article&#x2F;details&#x2F;60870719?spm&#x3D;1001.2014.3001.5502</a><br><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra">https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra</a><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650468407500-0de286f1-51b5-4568-b7a5-a5dc12bcfe0e.png"></p><h2 id="8、最短路径——弗洛伊德"><a href="#8、最短路径——弗洛伊德" class="headerlink" title="8、最短路径——弗洛伊德"></a>8、最短路径——弗洛伊德</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649163591901-50780cbd-549d-4838-bb3f-a5370ce25779.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649161963812-edcc979d-e347-42f8-b943-c4ed8ea591f2.png"></p><ul><li>使用邻接矩阵</li><li>动态规划思想</li><li>弗洛伊德算法是解决任意两点间的最短路径的一种算法</li><li>因为要维护一个路径矩阵，因此空间复杂度达到了O(n^2)，时间复杂度达到了O(n^3)，只有在数据规模很小的时候，才适合使用这个算法</li><li>矩阵A是邻接矩阵，而矩阵Path记录u,v两点之间最短路径所必须经过的点</li></ul><p>这个最好理解：<a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd">https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd</a><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649165443711-0df009a5-c0fa-42e7-990e-d6f02d4fcc4c.png"></p><h2 id="9、A-算法"><a href="#9、A-算法" class="headerlink" title="9、A*算法"></a>9、A*算法</h2><p><a href="https://zhuanlan.zhihu.com/p/103524779">A*算法原理浅析</a><br><a href="https://blog.csdn.net/A_L_A_N/article/details/81392212?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_antiscanv2&utm_relevant_index=6">A*算法具体实现</a><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/20220903170541.png"><br><strong>G</strong> 顶点到<strong>起始点</strong>距离<br>直 10  斜 14<br><strong>H</strong> 顶点到<strong>目标点</strong>距离<br>H 有很多计算方法, 这里我们设定只可以上下左右移动<br>F&#x3D;G+H  找<strong>F最小</strong>的格子</p><p><strong>最后，A星算法还需要用到两个列表：</strong><br><strong>开放列表</strong>- 用于记录所有可考虑选择的格子<br><strong>封闭列表</strong>- 用于记录所有不再考虑的格子</p><p><strong>流程如下：</strong></p><ul><li>首先将根节点放入队列中。</li><li>将根节点放入<strong>封闭列表</strong></li><li>开始循环</li><li><strong>从队列中找F值【总代价】最小的节点</strong>current</li><li>如果找到目标，则结束搜寻并回传结果。</li><li>否则将它所有<strong>尚未检验过</strong>的所有相邻节点加入队列中。</li><li>假如某邻近点既没有在<strong>开放列表</strong>或<strong>封闭列表</strong>里面，则计算出该邻近点的g值和h值，并设父节点为P，然后将其放入<strong>开放列表</strong></li><li>gCost &#x3D; current.gCost + GetDistance(current, neighbor);</li><li>hCost &#x3D; GetDistance(end, neighbor);</li><li>直至没有节点可以访问.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、十大排序&quot;&gt;&lt;a href=&quot;#一、十大排序&quot; class=&quot;headerlink&quot; title=&quot;一、十大排序&quot;&gt;&lt;/a&gt;一、十大排序&lt;/h1&gt;&lt;h2 id=&quot;1、冒泡排序-O-n2-稳定&quot;&gt;&lt;a href=&quot;#1、冒泡排序-O-n2-稳定&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>InsideUE4——GamePlay框架总结</title>
    <link href="http://example.com/2022/09/02/InsideUE4%E2%80%94%E2%80%94GamePlay%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/09/02/InsideUE4%E2%80%94%E2%80%94GamePlay%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</id>
    <published>2022-09-02T15:24:34.000Z</published>
    <updated>2022-09-03T08:16:41.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote><p>为了面试口述，内容有省略，后续会完善。<br>大钊也表示Damage确实不是AActor应该管的事情。</p></blockquote><p>首先是UObject，提供了反射、GC、序列化等等属性，因为提供了很强大的这些基本属性，UObject基本是UE中一切类的起源。</p><p>Actor就是继承于UObject，添加了网络复制、Tick等等。Actor在UE中既包含具象化的实体，也包含一些看不到的信息、状态、规则，比如AInfo系列（GameMode、GameState这些）。所以Actor并不是自带Transform的，而是将Transform封装到了SceneComponent当做RootComponent，对外暴露出GetActorLocation这些。至于为什么要将Info继承自Actor而不是另起一套，我觉得可能是需要Tick、网络复制等等，但是Component、Damage对于Info来说又好像确实是冗余的，这里还不是很明白。</p><p>然后是Component，这其中也是“组合优于继承”的一种理念吧，如果什么都靠继承，那类的数量必然会相当爆炸。所以UE中的Actor就是靠各种Component组合而成。而Component也往下分为了两类，一类是有变换的SceneComponent（比如StaticMeshComponent），另一类是直接继承自ActorComponent的（比如UMovementComponent）。UE在SceneComponent这一级才提供了组件嵌套的能力，这个觉得也是合理的，毕竟组件嵌套最主要还是为了Transform的跟随。给移动组件添加嵌套能力也没啥作用，还容易让使用者产生困惑。</p><p>那对于游戏中大量Acotr的组织，UE是采用了多个Level组成World，每个Level管理自己内部的Acotr，这其实就是将游戏世界给细化了。同时每个Level也有自己的关卡蓝图，可以设置场景的静态属性比如重力等等。这种模式还有些别的好处，一是World管理着Level的动态加载与释放，可以节省性能；二是多个Level可以并行地编辑等等。</p><p>一个World可以管理多个Level，而World也不止一个，在UE中编辑器本身、预览窗口、运行后的游戏都是World，有点“平行世界”的意思，其中一个World对应一个WorldContext。World放在WorldContext来管理的，而WorldContext又是放在GameInstance来管理的。</p><p>然后是Pawn，Pawn继承自Actor，一些特点包括可被Controller控制、有移动组件输入的接口，默认是开启了网络复制的。从Pawn开始，就是一般游戏中玩家所直接控制的了。角色也不用多说，主要是对Pawn进行了扩展，包括骨架网格体、胶囊体组件、角色移动组件等等。</p><p>Controller是单独抽离出来用来控制Pawn的一个类，且能够切换所控制的Pawn，PlayerState是可以存放一些玩家的数据。这三者是平级的并且一对一对一的关系，跟UE的网络关系很密切。</p><p>Controller又分为PlayerController和AIController。其中PlayerController直接跟玩家关联、并能够接收玩家设备的输入、提供摄像机管理等等。AIController就是提供了一些AI组件，运行行为树功能等等。</p><p>然后是GameMode，GameMode主要是负责一些初始类的登记（比如默认的Pawn、PlayerController等等），以及负责游戏整体的逻辑，制定规则与玩法什么的。但是在网络游戏中，GameMode是只存在于服务端，客户端是不存在的，那为了一些数据的复制，就衍生出了GameState。这样也实现了一个游戏整体上逻辑与数据的解耦分离。此外，对于玩家控制器，客户端是只持有本地的那一个，服务端则是拥有所有的。</p><p>还有一个Player类，这个类也很重要，但是其功能基本都在幕后实现了，一般业务里也接触不到。而他派生出的LocalPlayer类是对应到了咱们玩游戏时的视口。</p><p>GameInstance在一次游戏中是唯一的，负责了引擎初始化、玩家创建、网络等等，一些全局性的配置或者比较独立的业务比如UI也可以放在这里。</p><p>UE也提供了GamePlayStatics这样一个静态类，来方便我们调用一些游戏内的函数（GetActorOfClass、Spawn等等）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;个人总结&quot;&gt;&lt;a href=&quot;#个人总结&quot; class=&quot;headerlink&quot; title=&quot;个人总结&quot;&gt;&lt;/a&gt;个人总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为了面试口述，内容有省略，后续会完善。&lt;br&gt;大钊也表示Damage确实不是AActor应该管的事</summary>
      
    
    
    
    
    <category term="UE4" scheme="http://example.com/tags/UE4/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/09/01/hello-world/"/>
    <id>http://example.com/2022/09/01/hello-world/</id>
    <published>2022-09-01T15:10:31.126Z</published>
    <updated>2022-09-01T15:10:31.126Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
