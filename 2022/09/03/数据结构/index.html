<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords"><meta name="descriptioon" content=""><meta name="renderer" content="wekit"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/public.css"><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="/css/iconfont.css"><script>var _hmt = _hmt || [];(function(){var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?7b429839b56cf831028b7ac4cb9b5086";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})()</script><title>数据结构 [ Hexo ]</title><link rel="stylesheet" href="/css/partial/footer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="stylesheet" href="/css/partial/sidebar.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="scroll"><link rel="stylesheet" href="/css/partial/header.css"><div class="header scroll"><div class="maxwidth"><div class="nav"><a id="artlist" href="/404"><i class="iconfont icon404"></i><span class="headhid">&nbsp;404</span></a><a id="artlist" href="/archives"><i class="iconfont iconarchives"></i><span class="headhid">&nbsp;Archives</span></a><a id="artlist" href="/link"><i class="iconfont iconlink"></i><span class="headhid">&nbsp;Link</span></a><a id="artlist" href="/about"><i class="iconfont iconabout"></i><span class="headhid">&nbsp;About</span></a></div><div class="search">TONG-H</div></div></div><div class="main"> <div class="maxwidth"><link rel="stylesheet" href="/css/partial/sidebar.css"><div class="scroll" id="sidebar"><div class="social"><a href="/archives" title="Home"><i class="iconfont iconHome"></i></a><a href="1813828837@qq.com" title="E-Mail"><i class="iconfont iconweibiaoti554"></i></a><a target="_blank" rel="noopener" href="https://github.com/Ginkgowind" title="GitHub"><i class="iconfont iconGitHub"></i></a></div><div class="structure category-list"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">一、十大排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-O-n2-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.1.</span> <span class="toc-text">1、冒泡排序 O(n2) 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-O-n2-%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.2.</span> <span class="toc-text">2、选择排序 O(n2) 不稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-O-n2-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.3.</span> <span class="toc-text">3、插入排序 O(n2) 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.4.</span> <span class="toc-text">4、希尔排序 不稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-O-log-n-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.5.</span> <span class="toc-text">5、归并排序 O(log n) 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-O-nlogn-%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.6.</span> <span class="toc-text">6、快速排序 O(nlogn) 不稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F-O-nlogn-%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.7.</span> <span class="toc-text">7、堆排序 O(nlogn) 不稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-%E2%89%88O-n-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.8.</span> <span class="toc-text">8、计数排序 ≈O(n) 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F-O-n-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.9.</span> <span class="toc-text">9、桶排序 O(n) 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.10.</span> <span class="toc-text">10、基数排序 稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%951%EF%BC%9A%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.11.</span> <span class="toc-text">附录1：各种排序算法的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%952%EF%BC%9A%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9%E6%80%BB%E8%A7%88"><span class="toc-number">1.12.</span> <span class="toc-text">附录2：各种排序算法的特点总览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-%EF%BC%88%E6%89%93%E4%B9%B1%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">二、洗牌算法 （打乱）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%8A%BD%E7%89%8C%E5%B9%B6%E6%8B%BF%E5%87%BA%E6%9D%A5%E6%94%BE%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%BC%80%E5%A4%B4%EF%BC%8C%E5%BC%80%E5%A4%B4%E4%B8%8D%E6%96%AD%E5%90%8E%E6%8E%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1、抽牌并拿出来放在另一个数组开头，开头不断后推</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%8A%BD%E7%89%8C%E5%B9%B6%E4%B8%8E%E6%9C%AB%E5%B0%BE%E7%9A%84%E5%85%83%E7%B4%A0%E4%BA%A4%E6%8D%A2%EF%BC%8C%E6%9C%AB%E5%B0%BE%E4%B8%8D%E6%96%AD%E5%89%8D%E6%8E%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2、抽牌并与末尾的元素交换，末尾不断前推</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BB%8E%E5%89%8D%E5%BE%80%E5%90%8E%EF%BC%8C%E5%8F%AF%E9%80%82%E5%BA%94%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0"><span class="toc-number">2.3.</span> <span class="toc-text">3、从前往后，可适应动态增加</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">三、循环队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">四、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">1、哈希函数的构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.</span> <span class="toc-text">2、哈希冲突的解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87"><span class="toc-number">4.3.</span> <span class="toc-text">3、哈希表的查找效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">4.4.</span> <span class="toc-text">4、哈希表的删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">五、树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.1.</span> <span class="toc-text">1、二叉树的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81AVL%E6%A0%91-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">1、AVL树 平衡二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81B%E6%A0%91-%E5%B9%B3%E8%A1%A1%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">2、B树 平衡多路查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81B-%E6%A0%91-B%E6%A0%91%E7%9A%84%E5%8D%87%E7%BA%A7%E7%89%88"><span class="toc-number">5.4.</span> <span class="toc-text">3、B+树 B树的升级版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E4%B8%8EB-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">B树与B+树的一些区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">5.5.</span> <span class="toc-text">4、红黑树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">六、图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">6.1.</span> <span class="toc-text">1、名词解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">2、图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E8%8B%A5%E6%98%AF%E7%BD%91%E5%B0%B1%E4%BD%BF%E7%94%A8%E6%9D%83%E5%80%BC%E6%9D%A5%E4%BB%A3%E6%9B%BF%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.邻接矩阵（若是网就使用权值来代替元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">3.十字链表（有向图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89-%E5%82%A8%E5%AD%98%E7%9A%84%E6%98%AF%E8%BE%B9"><span class="toc-number">6.2.4.</span> <span class="toc-text">4.邻接多重表（无向图） 储存的是边</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94BFS%E5%92%8CDFS"><span class="toc-number">6.3.</span> <span class="toc-text">3、图的遍历——BFS和DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">4、最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95%E2%80%94Prim%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">1.普里姆算法—Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%E7%A7%8D%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%EF%BC%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">2.克鲁斯卡算法（一种贪心策略）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">5、拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">6.6.</span> <span class="toc-text">6、关键路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89"><span class="toc-number">6.7.</span> <span class="toc-text">7、最短路径——迪杰斯特拉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7"><span class="toc-number">6.8.</span> <span class="toc-text">8、最短路径——弗洛伊德</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81A-%E7%AE%97%E6%B3%95"><span class="toc-number">6.9.</span> <span class="toc-text">9、A*算法</span></a></li></ol></li></ol></div><div class="tags"><a href="/tags/C/" style="font-size: 12px; color: #ffac00">C++</a> <a href="/tags/UE4/" style="font-size: 12px; color: #ffac00">UE4</a> <a href="/tags/cs/" style="font-size: 12px; color: #ffac00">cs</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 12px; color: #ffac00">图形学</a> <a href="/tags/%E5%A5%BD%E6%96%87%E6%8E%A8%E8%8D%90/" style="font-size: 12px; color: #ffac00">好文推荐</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px; color: #ffac00">数据结构</a></div></div><div class="post rightside"><div class="artititle">数据结构</div><div class="info"><i class="iconfont iconbiaoqian" title="文章标签"><span>数据结构</span></i><i class="iconfont iconshijian"><span title="文章发布时间">2022-09-03</span></i></div><div class="postDetail"><h1 id="一、十大排序"><a href="#一、十大排序" class="headerlink" title="一、十大排序"></a>一、十大排序</h1><h2 id="1、冒泡排序-O-n2-稳定"><a href="#1、冒泡排序-O-n2-稳定" class="headerlink" title="1、冒泡排序 O(n2) 稳定"></a>1、冒泡排序 <strong>O(n2) 稳定</strong></h2><p>以构造递增数组为例<br>双层循环，从前往后依次比较两个相邻元素，若前一个大于后一个，就交换。让数组从后往前，每一个当前元素都是剩余元素最大的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++ )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; len - <span class="number">1</span> - i ; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、选择排序-O-n2-不稳定"><a href="#2、选择排序-O-n2-不稳定" class="headerlink" title="2、选择排序 O(n2) 不稳定"></a>2、选择排序 <strong>O(n2) 不稳定</strong></h2><p>双层循环，每一轮记录最小元素的下标，并交换到循环开始的位置</p>
<h2 id="3、插入排序-O-n2-稳定"><a href="#3、插入排序-O-n2-稳定" class="headerlink" title="3、插入排序 O(n2) 稳定"></a>3、插入排序 <strong>O(n2) 稳定</strong></h2><p>类似于整理手里的扑克牌<br>从前往后依次取出，记为value，并往前比较，如果大于value就往后移；直到遇到小于value的，就插入在那里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr=&#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> value = arr[i];</span><br><span class="line">    <span class="type">int</span> j ;<span class="comment">//插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; value) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];<span class="comment">//移动数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>] = value; <span class="comment">//插入数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(arr);</span><br></pre></td></tr></table></figure>
<h2 id="4、希尔排序-不稳定"><a href="#4、希尔排序-不稳定" class="headerlink" title="4、希尔排序 不稳定"></a>4、希尔排序 不<strong>稳定</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif"></p>
<ul>
<li>插入排序对于大规模的乱序数组的时候效率是比较慢的，因为它每次只能将数据移动一位，希尔排序为了加快插入的速度，让数据移动的时候可以实现跳跃移动，节省了一部分的时间开支。</li>
<li>对每个分组采用插入排序</li>
<li>起始区间一般选择二分之一到三分之一附近</li>
<li>当区间为 1 的时候，它使用的排序方式就是插入排序。</li>
</ul>
<h2 id="5、归并排序-O-log-n-稳定"><a href="#5、归并排序-O-log-n-稳定" class="headerlink" title="5、归并排序 O(log n) 稳定"></a>5、归并排序 O(log n) <strong>稳定</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650002894967-756bdac0-b0e5-49a6-9c1f-b8e686f25d1d.jpeg"></p>
<ul>
<li><p>需要一个辅助数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums,tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//划分</span></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//分成两份后分别的结果相加</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(l,m,nums,tmp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(m+<span class="number">1</span>,r,nums,tmp);</span><br><span class="line">    <span class="comment">//将[l,r]用一个数组保存合并之前的模样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对[l,r]中的[l,m]、[m+1,r]开始合并</span></span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">int</span> j = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m及其左边元素合并完毕,把右边剩下的放入合并后的数组</span></span><br><span class="line">        <span class="keyword">if</span>(i==m+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = tmp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//m+1及其右边元素合并完毕,把左边剩下的放入合并后的数组 或者 左边数组的元素小于等于右边,将左边数组的元素放入结果数组中,并让索引i加1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j==r+<span class="number">1</span> || tmp[i]&lt;=tmp[j])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = tmp[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右边数组的元素小于左边,将右边数组的元素其放入结果数组中,并让索引j加1</span></span><br><span class="line">        <span class="comment">//并且此时左边数组中的从i到m的所有数都是大于tmp[j]的(因为m左右的数组都是已经排好序的，第15行代码的功劳)</span></span><br><span class="line">        <span class="comment">//即此时有m-i+1个逆序对，加到res上即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//即if(tmp[i]&gt;tmp[j])这种情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[k] = tmp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>merge 方法中只有一个 for 循环，直接就可以得出每次合并的时间复杂度为 O(n) ，而分解数组每次对半切割，属于对数时间 O(log n) ，合起来等于 O(log2n) ，也就是说，总的时间复杂度为 O(nlogn) 。</p>
</li>
</ul>
<h2 id="6、快速排序-O-nlogn-不稳定"><a href="#6、快速排序-O-nlogn-不稳定" class="headerlink" title="6、快速排序 O(nlogn) 不稳定"></a>6、快速排序 O(nlogn) 不<strong>稳定</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对arr数组进行排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分操作（以 arr[l] 作为基准数）</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;	<span class="comment">//最后 i==j</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[l]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">recur</span>(arr, l, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">recur</span>(arr, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、堆排序-O-nlogn-不稳定"><a href="#7、堆排序-O-nlogn-不稳定" class="headerlink" title="7、堆排序 O(nlogn) 不稳定"></a>7、堆排序 O(nlogn) 不<strong>稳定</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 构建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    <span class="built_in">sink</span>(nums,i,len);</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="comment">//将堆顶元素与末位元素调换</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[i]);</span><br><span class="line">    <span class="comment">//数组长度-1 隐藏堆尾元素</span></span><br><span class="line">    len--;</span><br><span class="line">    <span class="comment">//将堆顶元素下沉 目的是将最大的元素浮到堆顶来</span></span><br><span class="line">    <span class="built_in">sink</span>(nums, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> i,<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> now=i;</span><br><span class="line">    <span class="comment">//下沉左边</span></span><br><span class="line">    <span class="keyword">if</span> (left&lt;len &amp;&amp; nums[left]&gt;nums[now]) now=left;</span><br><span class="line">    <span class="comment">//下沉右边</span></span><br><span class="line">    <span class="keyword">if</span> (right&lt;len &amp;&amp; nums[right]&gt;nums[now]) now=right;</span><br><span class="line">    <span class="comment">//如果下标不相等 证明调换过了</span></span><br><span class="line">    <span class="keyword">if</span> (now!=i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[now]);</span><br><span class="line">        <span class="built_in">sink</span>(nums,now,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、计数排序-≈O-n-稳定"><a href="#8、计数排序-≈O-n-稳定" class="headerlink" title="8、计数排序 ≈O(n) 稳定"></a>8、计数排序 ≈O(n) <strong>稳定</strong></h2><p>以[ 3，5，8，2，5，4 ]这组数字来演示。<br>首先，我们找到这组数字中最大的数，也就是 8，创建一个最大下标为 8 的空数组 arr 。<br>遍历数据，将数据的出现次数填入arr中对应的下标位置中。<br>最后遍历 arr ，将数据依次取出即可。</p>
<ul>
<li>计数排序只适用于正整数并且取值范围相差不大的数组排序使用，它的排序的速度是非常可观的。</li>
</ul>
<h2 id="9、桶排序-O-n-稳定"><a href="#9、桶排序-O-n-稳定" class="headerlink" title="9、桶排序 O(n) 稳定"></a>9、桶排序 O(n) <strong>稳定</strong></h2><p>桶排序可以看成是计数排序的升级版，它将要排的数据分到多个有序的桶里，每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序。<br>在额外空间充足的情况下，尽量增大桶的数量，极限情况下每个桶只有一个数据时，或者是每只桶只装一个值时，完全避开了桶内排序的操作，桶排序的最好时间复杂度就能够达到 O(n)。</p>
<h2 id="10、基数排序-稳定"><a href="#10、基数排序-稳定" class="headerlink" title="10、基数排序 稳定"></a>10、基数排序 <strong>稳定</strong></h2><p>基数排序是一种非比较型整数排序算法，其原理是将数据按位数切割成不同的数字，然后按每个位数分别比较。<br>需要创建十个桶来对应每一位0~9的是个数字<br>先排个位数，根据个位数的值将数据放到对应下标值的桶中。接下来排十位数、百位数。<br>最后取出的就是有序数组。</p>
<h2 id="附录1：各种排序算法的稳定性"><a href="#附录1：各种排序算法的稳定性" class="headerlink" title="附录1：各种排序算法的稳定性"></a>附录1：各种排序算法的稳定性</h2><p>稳定排序 ：冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序<br>不稳定排序 ：快速排序、希尔排序、选择排序、堆排序</p>
<h2 id="附录2：各种排序算法的特点总览"><a href="#附录2：各种排序算法的特点总览" class="headerlink" title="附录2：各种排序算法的特点总览"></a>附录2：各种排序算法的特点总览</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650006879516-3f0b4659-29cb-4183-8615-c6dd75ca8dea.png"></p>
<h1 id="二、洗牌算法-（打乱）"><a href="#二、洗牌算法-（打乱）" class="headerlink" title="二、洗牌算法 （打乱）"></a>二、洗牌算法 （打乱）</h1><h2 id="1、抽牌并拿出来放在另一个数组开头，开头不断后推"><a href="#1、抽牌并拿出来放在另一个数组开头，开头不断后推" class="headerlink" title="1、抽牌并拿出来放在另一个数组开头，开头不断后推"></a>1、抽牌并拿出来放在另一个数组开头，开头不断后推</h2><p>基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，使用了vector的erase。</p>
<ol>
<li>初始化原始数组和<strong>辅助数组</strong>，原始数组长度为n(已知)；</li>
<li>从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）；</li>
<li>从剩下的k个数中把第p个数取出；</li>
<li>重复步骤2和3直到数字全部取完；</li>
<li>从步骤3取出的数字序列便是一个打乱了的数列。</li>
</ol>
<h2 id="2、抽牌并与末尾的元素交换，末尾不断前推"><a href="#2、抽牌并与末尾的元素交换，末尾不断前推" class="headerlink" title="2、抽牌并与末尾的元素交换，末尾不断前推"></a>2、抽牌并与末尾的元素交换，末尾不断前推</h2><p>对1的改进，<strong>省去了额外O(n)的空间</strong>。基本思想类似，每次从未处理的数据中随机取出一个数字，然后把该数字与数组的尾部交换，即数组尾部存放的是已经处理过的数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Knuth_Durstenfeld_Shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=arr.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">		<span class="built_in">swap</span>(arr[<span class="built_in">rand</span>()%(i+<span class="number">1</span>)],arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>对于arr[i],洗牌后在第n-1个位置的概率是1&#x2F;n（第一次交换的随机数为i）<br>在n-2个位置概率是[(n-1)&#x2F;n] * [1&#x2F;(n-1)] &#x3D; 1&#x2F;n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i&#x3D;n-1，第一交换arr[n-1]会被换到一个随机的位置））<br>在第n-k个位置的概率是[(n-1)&#x2F;n] * [(n-2)&#x2F;(n-1)] <em>…</em> [(n-k+1)&#x2F;(n-k+2)] *[1&#x2F;(n-k+1)] &#x3D; 1&#x2F;n<br>（第一个随机数不要为i，第二次不为arr[i]所在的位置(随着交换有可能会变)……第n-k次为arr[i]所在的位置）.</p>
<h2 id="3、从前往后，可适应动态增加"><a href="#3、从前往后，可适应动态增加" class="headerlink" title="3、从前往后，可适应动态增加"></a>3、从前往后，可适应动态增加</h2><p>基本思想是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k），这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">rand</span>()%(i+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(res[i],res[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证明如下：<br>原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1&#x2F;i) * [i&#x2F;(i+1)] * [(i+1)&#x2F;(i+2)] <em>…</em> [(n-1)&#x2F;n] &#x3D; 1&#x2F;n，（即第i次刚好随机放到了该位置，在后面的n-i 次选择中该数字不被选中）。<br>原数组的第 i 个元素（随机到的数）在新数组的 i+1 （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1&#x2F;k) * [k&#x2F;(k+1)] * [(k+1)&#x2F;(k+2)] <em>…</em> [(n-1)&#x2F;n] &#x3D; 1&#x2F;n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。</p>
<h1 id="三、循环队列"><a href="#三、循环队列" class="headerlink" title="三、循环队列"></a>三、循环队列</h1><p>用数组来储存，初始设置容量MAXQSIZE<br>队列长度：Q.rear-Q.front；<br>队头元素：Q.base[Q.front]；<br>队尾元素：Q.base[Q.rear-1]；<br>即rear指向的是空</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 添加元素</span><br><span class="line"><span class="function">status <span class="title">EnQueue</span><span class="params">(SqQueue *q,QElemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入到队尾</span></span><br><span class="line">    <span class="keyword">if</span>((q-&gt;rear+<span class="number">1</span>)%MAXQSIZE==q-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;base[q-&gt;rear]=e;</span><br><span class="line">    q-&gt;rear=(q-&gt;rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 删除元素</span><br><span class="line"><span class="function">status <span class="title">EnQueue</span><span class="params">(SqQueue *q,QElemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(<span class="keyword">this</span>)) 		<span class="comment">// 以后再改</span></span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> item = <span class="keyword">this</span>.array[<span class="keyword">this</span>.front]; </span><br><span class="line">    <span class="keyword">this</span>.front = (<span class="keyword">this</span>.front + <span class="number">1</span>)%<span class="keyword">this</span>.capacity; </span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> item; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> 获取队列长度</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;rear-q-&gt;front+MAXQSIZE)%MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、哈希表"><a href="#四、哈希表" class="headerlink" title="四、哈希表"></a>四、哈希表</h1><h2 id="1、哈希函数的构造方法"><a href="#1、哈希函数的构造方法" class="headerlink" title="1、哈希函数的构造方法"></a>1、哈希函数的构造方法</h2><ol>
<li>直接定制：弄一个线性函数</li>
<li>数字分析：分析key中的全体数据，并从中提取分布均匀的若干位或他们的组合构成全体</li>
<li>平方取中法：如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。</li>
<li>折叠法：如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为hash地址</li>
<li>除留余数法：用的较多</li>
</ol>
<p>H（key）&#x3D;key MOD p （p&lt;&#x3D;m m为表长）<br>p应为不大于m的质数或是不含20以下的质因子的合数，这样可以减少地址的重复（冲突）</p>
<ol start="6">
<li>随机数法：H（key） &#x3D;Random（key） 取关键字的随机函数值为它的散列地址</li>
</ol>
<h2 id="2、哈希冲突的解决方案"><a href="#2、哈希冲突的解决方案" class="headerlink" title="2、哈希冲突的解决方案"></a>2、哈希冲突的解决方案</h2><ol>
<li>开放定制法<ol>
<li>线性探测再散列</li>
<li>平方探测再散列</li>
<li>随机探测再散列</li>
</ol>
</li>
<li>链地址法：每个地址维护一个链表，冲突就后延</li>
<li>公共溢出区法：建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况</li>
<li>再散列法：准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……</li>
</ol>
<h2 id="3、哈希表的查找效率"><a href="#3、哈希表的查找效率" class="headerlink" title="3、哈希表的查找效率"></a>3、哈希表的查找效率</h2><p>装载因子 α&#x3D;n&#x2F;m(n表示实际装载数据长度 m为表长)<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650037230644-da9b98de-69a1-4a2e-af1b-7d65e6084b31.png"></p>
<h2 id="4、哈希表的删除"><a href="#4、哈希表的删除" class="headerlink" title="4、哈希表的删除"></a>4、哈希表的删除</h2><p>首先链地址法是可以直接删除元素的，但是开放定址法是不行的，拿前面的双探测再散列来说，假如我们删除了元素1，将其位置置空，那 23就永远找不到了。正确做法应该是删除之后置入一个原来不存在的数据，比如-1<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650271022196-22c0ab00-906a-4aa4-9724-8dfe3ace1755.png"></p>
<h1 id="五、树"><a href="#五、树" class="headerlink" title="五、树"></a>五、树</h1><h2 id="1、二叉树的遍历"><a href="#1、二叉树的遍历" class="headerlink" title="1、二叉树的遍历"></a>1、二叉树的遍历</h2><ul>
<li>先序和中序代码中，变化的只有访问元素的位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>非递归先序遍历</span><br><span class="line"><span class="comment">// 思路：其实一般要想通过非递归的方式实现递归方式的算法，一般都是要使用栈。</span></span><br><span class="line"><span class="comment">// 首先我们的循环条件是：结点不为空或者栈不为空。然后是先把根结点加入桟中，</span></span><br><span class="line"><span class="comment">// 然后，遍历左子树，当左子树遍历完后，栈顶元素为刚刚的根结点，</span></span><br><span class="line"><span class="comment">// 然后，让根结点出栈，遍历右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderTraverse_no_recursive</span><span class="params">(Tree_Node * T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;Tree_Node*&gt; s;</span><br><span class="line">    Tree_Node * p=T;</span><br><span class="line">        <span class="comment">//栈不为空或者T不为空时，循环继续</span></span><br><span class="line">    <span class="keyword">while</span>(p || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p); <span class="comment">//根结点入栈</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">//访问根结点</span></span><br><span class="line">            p=p-&gt;left; <span class="comment">//先遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>(); <span class="comment">//根结点出栈</span></span><br><span class="line">            s.<span class="built_in">pop</span>();   <span class="comment">//</span></span><br><span class="line">            p=p-&gt;right;<span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 非递归中序遍历二叉树</span><br><span class="line"><span class="comment">// 思路：T是要遍历树的根指针，中序遍历要求在遍历完左子树后，访问根，再遍历右子树。 </span></span><br><span class="line"><span class="comment">// 先将T入栈，遍历左子树；遍历完左子树返回时，栈顶元素应为T，出栈，</span></span><br><span class="line"><span class="comment">// 访问T-&gt;data，再中序遍历T的右子树。 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverse_recursive</span><span class="params">(Tree_Node * T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;Tree_Node*&gt; s;</span><br><span class="line">    Tree_Node * p=T;</span><br><span class="line">        <span class="comment">//栈不为空或者T不为空时，循环继续</span></span><br><span class="line">    <span class="keyword">while</span>(p || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p); <span class="comment">//根结点入栈</span></span><br><span class="line">            p=p-&gt;left; <span class="comment">//先遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>(); <span class="comment">//根结点出栈，也就是把之前的左节点提出来</span></span><br><span class="line">            s.<span class="built_in">pop</span>();   <span class="comment">//</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">//访问根结点</span></span><br><span class="line">            p=p-&gt;right;<span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 后序遍历有点复杂了，不想看，下面放个链接</span><br><span class="line">https:<span class="comment">//blog.csdn.net/qq_35644234/article/details/53013738</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1、AVL树-平衡二叉查找树"><a href="#1、AVL树-平衡二叉查找树" class="headerlink" title="1、AVL树 平衡二叉查找树"></a>1、AVL树 平衡二叉查找树</h2><h2 id="2、B树-平衡多路查找树"><a href="#2、B树-平衡多路查找树" class="headerlink" title="2、B树 平衡多路查找树"></a>2、B树 平衡多路查找树</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650096843736-e58e55ec-a4f3-48b7-a979-530d24c5c2fc.png"><br><strong>特点：</strong></p>
<ol>
<li>定义阶数m</li>
<li>每个结点最多有m-1个关键字</li>
<li><strong>根结点</strong>最少可以只有1个关键字。</li>
<li><strong>非根结点</strong>至少有int(m&#x2F;2)个关键字。</li>
<li>每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li>
<li>所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</li>
</ol>
<p><strong>查询流程：</strong><br>如上图我要从上图中找到E字母，查找流程如下<br>（1）获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；<br>（2）拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；<br>（3）拿到E和F，因为E&#x3D;E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p>
<h2 id="3、B-树-B树的升级版"><a href="#3、B-树-B树的升级版" class="headerlink" title="3、B+树 B树的升级版"></a>3、B+树 B树的升级版</h2><p><strong>特点：</strong></p>
<ol>
<li>保存了两个指针，一个指向根节点，一个指向第一个叶子节点</li>
<li>所有的数据都在叶子节点，内部节点只储存索引</li>
<li>叶子节点形成了一个有序链表</li>
<li>非叶子节点的子节点数&#x3D;关键字数</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650100844216-2569d881-c53a-41ef-9df5-07f45fb4d10d.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650100741524-fdb5cd7d-4967-4ef2-b372-e565017a13c7.png"></p>
<h3 id="B树与B-树的一些区别："><a href="#B树与B-树的一些区别：" class="headerlink" title="B树与B+树的一些区别："></a>B树与B+树的一些区别：</h3><ol>
<li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>
<h2 id="4、红黑树"><a href="#4、红黑树" class="headerlink" title="4、红黑树"></a>4、红黑树</h2><h1 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h1><h2 id="1、名词解释"><a href="#1、名词解释" class="headerlink" title="1、名词解释"></a>1、名词解释</h2><ul>
<li>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。在图中的数据元素，我们称之为顶点（Vertex），顶点集合有穷非空。在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li>
<li>图按照边的有无方向分为无向图和有向图。无向图由顶点和边组成，有向图由顶点和弧构成。弧有弧尾和弧头之分，带箭头一端为弧头。</li>
<li>图按照边或弧的多少分稀疏图和稠密图。如果图中的任意两个顶点之间都存在边叫做<strong>完全图</strong>，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。</li>
<li>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度。有向图顶点分为入度和出度。</li>
<li>图上的边或弧带有权则称为<strong>网</strong>。</li>
<li>图中顶点间存在路径，<strong>两顶点存在路径则说明是连通的</strong>，如果路径最终回到起始点则称为环，当中不重复的叫简单路径。若任意两顶点都是连通的，则图就是<strong>连通图</strong>，有向则称为<strong>强连通图</strong>。图中有子图，若子图极大连通则就是连通分量，有向的则称为强连通分量。</li>
<li>无向图中连通且n个顶点n-1条边称为<strong>生成树</strong>。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</li>
</ul>
<h2 id="2、图的存储结构"><a href="#2、图的存储结构" class="headerlink" title="2、图的存储结构"></a>2、图的存储结构</h2><h3 id="1-邻接矩阵（若是网就使用权值来代替元素）"><a href="#1-邻接矩阵（若是网就使用权值来代替元素）" class="headerlink" title="1.邻接矩阵（若是网就使用权值来代替元素）"></a>1.邻接矩阵（若是网就使用权值来代替元素）</h3><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122551576-43adbd85-7aed-4cca-ad07-2b49ef5fba26.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122376601-d0fcf4f9-9d85-4543-b26a-fee998aa52cb.png"></p>
<ul>
<li>优点：直观、容易理解，可以很容易的判断出任意两个顶点是否有边，最大的优点就是很容易计算出各个顶点的度。</li>
<li>缺点：当我们表示完全图的时候，邻接矩阵是最好的表示方法，但是对于稀疏矩阵，由于它边少，但是顶点多，这样就会造成空间的浪费。</li>
</ul>
<h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2.邻接表"></a>2.邻接表</h3><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122631497-3b5fb955-139a-468e-a0d3-12bfc1fab1e0.png"></p>
<ul>
<li>优点：对于稀疏图，邻接表比邻接矩阵更节约空间。</li>
<li>缺点：不容易判断两个顶点是有关系（边），顶点的出度容易，但是求入度需要遍历整个邻接表。</li>
</ul>
<h3 id="3-十字链表（有向图）"><a href="#3-十字链表（有向图）" class="headerlink" title="3.十字链表（有向图）"></a>3.十字链表（有向图）</h3><blockquote>
<p>邻接表对于我们计算顶点的<strong>入度</strong>是一个很麻烦的事情，而十字链表正好可以解决这个问题。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122854571-9521b933-b48d-4aea-8800-eda4f5833165.png"></p>
<h3 id="4-邻接多重表（无向图）-储存的是边"><a href="#4-邻接多重表（无向图）-储存的是边" class="headerlink" title="4.邻接多重表（无向图） 储存的是边"></a>4.邻接多重表（无向图） 储存的是边</h3><blockquote>
<p>邻接多重表是无向图的另一种链式存储结构。我们之前也说了使用邻接矩阵来存储图比较浪费空间，但是如果我们使用邻接表来存储图时，对于无向图又有一些不便的地方，例如删除边的时候。<br>其中，头结点的结构和邻接表一样，而表结点中就改变比较大了，其中mark为标志域，例如标志是否已经访问过，ivex和jvex代表边的两个顶点在顶点表中的下标，ilink指向下一个依附在顶点ivex的边，jlink指向下一个依附在顶点jvex的边，weight在网图的时候使用，代表该边的权重。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649122927074-922ee49d-ac98-4e4e-a55c-384b19b4e4fd.png"></p>
<h2 id="3、图的遍历——BFS和DFS"><a href="#3、图的遍历——BFS和DFS" class="headerlink" title="3、图的遍历——BFS和DFS"></a>3、图的遍历——BFS和DFS</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649126768667-31b1a779-be79-4a23-9972-caafead765f3.png"></p>
<ol>
<li>DFS：使用邻接表，递归</li>
<li>BFS：也使用邻接表，队列</li>
</ol>
<ul>
<li>都需要一个一维数组visit来储存每个顶点是否被访问过</li>
</ul>
<h2 id="4、最小生成树"><a href="#4、最小生成树" class="headerlink" title="4、最小生成树"></a>4、最小生成树</h2><p>现在假设有一个很实际的问题：我们要在n个城市中建立一个通信网络，则连通这n个城市需要布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？<br>我们引入连通图来解决我们遇到的问题，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。<br>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：<strong>MST性质</strong>（假设N&#x3D;(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649128879149-b0df49ad-c73c-4475-907f-322eb6227ac5.png"></p>
<h3 id="1-普里姆算法—Prim算法"><a href="#1-普里姆算法—Prim算法" class="headerlink" title="1.普里姆算法—Prim算法"></a>1.普里姆算法—Prim算法</h3><h3 id="2-克鲁斯卡算法（一种贪心策略）"><a href="#2-克鲁斯卡算法（一种贪心策略）" class="headerlink" title="2.克鲁斯卡算法（一种贪心策略）"></a>2.克鲁斯卡算法（一种贪心策略）</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35644234/article/details/59106779?spm=1001.2014.3001.5502">博客链接</a></p>
<h2 id="5、拓扑排序"><a href="#5、拓扑排序" class="headerlink" title="5、拓扑排序"></a>5、拓扑排序</h2><p>对一个有向<strong>无环</strong>图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。拓扑排序对应施工的流程图具有特别重要的作用，它可以决定哪些子工程必须要先执行，哪些子工程要在某些工程执行后才可以执行。<br>通常，我们把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网(Activity On Vertex network)，简称<strong>AOV网</strong>。<br>AOV网不应有环。<br><strong>算法实现：</strong>（使用<strong>邻接表</strong>来初始化、改变别的顶点的入度）</p>
<ol>
<li>在有向图中选一个没有前驱的顶点并且输出</li>
<li>从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）</li>
<li>重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的，因此，也可以通过拓扑排序来判断一个图是否有环。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35644234/article/details/60578189?spm=1001.2014.3001.5502">博客链接</a></p>
<h2 id="6、关键路径"><a href="#6、关键路径" class="headerlink" title="6、关键路径"></a>6、关键路径</h2><p><strong>AOE-网</strong>只是比AOV-网多了一个边的权重，而且AOV-网一般是设计一个庞大的工程各个子工程实施的先后顺序，而我们的AOE-网就是不仅仅关系整个工程中各个子工程的实施的先后顺序，同时也关系整个工程完成最短时间。<br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649149699793-2f0e5ebb-51cd-4cb5-8e55-aff76a327859.png"></p>
<ol>
<li>事件（顶点）的最早发生时间：ve[k]	正向推<br> . 事件（顶点）的最迟发生时间：vl[k]	逆向推<br> . 活动（边）的最早发生时间：ee[i]	ee[i]&#x3D;ve[j]<ol>
<li>只有顶点Vk代表的事件发生，活动ai才能开始，即活动ai的最早开始时间等于事件Vk的最早开始时间。<br>   活动（边）的最迟发生时间：el[i]	el[i]&#x3D;vl[k]-a[ ]<em>(dut(&lt;j,k&gt;))</em></li>
<li>el[i]是指在不推迟整个工期的前提下，活动ai必须开始的最晚时间。若活动ai由有向边&lt;Vk, Vj&gt;表示，则ai的最晚开始时间要保证事件vj的最迟发生时间不拖后。</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650273091022-ad21d927-fd19-42ba-8ff2-71c9095413b2.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649160701607-cce6569e-7d9b-4bd9-9ff1-ea83d8529385.png"><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fu_jian_ping/article/details/88962697?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164914917516780261936274%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164914917516780261936274&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-88962697.142%5Ev5%5Epc_search_insert_es_download,157%5Ev4%5Enew_style&utm_term=%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84&spm=1018.2226.3001.4187">博客链接</a></p>
<h2 id="7、最短路径——迪杰斯特拉"><a href="#7、最短路径——迪杰斯特拉" class="headerlink" title="7、最短路径——迪杰斯特拉"></a>7、最短路径——迪杰斯特拉</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650467990251-a3db2a77-9da3-44c5-8fa1-ce3ff8fac5f6.png"></p>
<ul>
<li>使用邻接矩阵</li>
<li>贪心思想</li>
<li>解决单源最短路径问题</li>
<li>该算法复杂度为n^2,我们可以发现，如果边数远小于n^2,对此可以考虑用堆这种数据结构进行优化，取出最短路径的复杂度降为O(1)。每次调整的复杂度降为O（elogn）；e为该点的边数，所以复杂度降为O((m+n)logn)。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35644234/article/details/60870719?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_35644234&#x2F;article&#x2F;details&#x2F;60870719?spm&#x3D;1001.2014.3001.5502</a><br><a target="_blank" rel="noopener" href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra">https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra</a><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1650468407500-0de286f1-51b5-4568-b7a5-a5dc12bcfe0e.png"></p>
<h2 id="8、最短路径——弗洛伊德"><a href="#8、最短路径——弗洛伊德" class="headerlink" title="8、最短路径——弗洛伊德"></a>8、最短路径——弗洛伊德</h2><p><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649163591901-50780cbd-549d-4838-bb3f-a5370ce25779.png"><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649161963812-edcc979d-e347-42f8-b943-c4ed8ea591f2.png"></p>
<ul>
<li>使用邻接矩阵</li>
<li>动态规划思想</li>
<li>弗洛伊德算法是解决任意两点间的最短路径的一种算法</li>
<li>因为要维护一个路径矩阵，因此空间复杂度达到了O(n^2)，时间复杂度达到了O(n^3)，只有在数据规模很小的时候，才适合使用这个算法</li>
<li>矩阵A是邻接矩阵，而矩阵Path记录u,v两点之间最短路径所必须经过的点</li>
</ul>
<p>这个最好理解：<a target="_blank" rel="noopener" href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd">https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd</a><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/1649165443711-0df009a5-c0fa-42e7-990e-d6f02d4fcc4c.png"></p>
<h2 id="9、A-算法"><a href="#9、A-算法" class="headerlink" title="9、A*算法"></a>9、A*算法</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/103524779">A*算法原理浅析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/A_L_A_N/article/details/81392212?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_antiscanv2&utm_relevant_index=6">A*算法具体实现</a><br><img src="https://cdn.jsdelivr.net/gh/Ginkgowind/BlogImage@main/20220903170541.png"><br><strong>G</strong> 顶点到<strong>起始点</strong>距离<br>直 10  斜 14<br><strong>H</strong> 顶点到<strong>目标点</strong>距离<br>H 有很多计算方法, 这里我们设定只可以上下左右移动<br>F&#x3D;G+H  找<strong>F最小</strong>的格子</p>
<p><strong>最后，A星算法还需要用到两个列表：</strong><br><strong>开放列表</strong>- 用于记录所有可考虑选择的格子<br><strong>封闭列表</strong>- 用于记录所有不再考虑的格子</p>
<p><strong>流程如下：</strong></p>
<ul>
<li>首先将根节点放入队列中。</li>
<li>将根节点放入<strong>封闭列表</strong></li>
<li>开始循环</li>
<li><strong>从队列中找F值【总代价】最小的节点</strong>current</li>
<li>如果找到目标，则结束搜寻并回传结果。</li>
<li>否则将它所有<strong>尚未检验过</strong>的所有相邻节点加入队列中。</li>
<li>假如某邻近点既没有在<strong>开放列表</strong>或<strong>封闭列表</strong>里面，则计算出该邻近点的g值和h值，并设父节点为P，然后将其放入<strong>开放列表</strong></li>
<li>gCost &#x3D; current.gCost + GetDistance(current, neighbor);</li>
<li>hCost &#x3D; GetDistance(end, neighbor);</li>
<li>直至没有节点可以访问.</li>
</ul>
</div></div><link rel="stylesheet" href="/css/partial/footer.css"><div class="footer"><p><span>Copyright © 2017 - 2022  </span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">蜀ICP备19024124号</a></p><p><i class="iconfont iconchakan"><span>本站总访问量</span><span id="busuanzi_container_site_pv">  <span id="busuanzi_value_site_pv"></span> </span></i><i class="iconfont iconabout"><span>本站访客数</span><span id="busuanzi_container_site_uv">  <span id="busuanzi_value_site_uv"></span> </span></i></p></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>