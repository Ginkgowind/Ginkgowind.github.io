<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords"><meta name="descriptioon" content=""><meta name="renderer" content="wekit"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/public.css"><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="/css/iconfont.css"><script>var _hmt = _hmt || [];(function(){var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?7b429839b56cf831028b7ac4cb9b5086";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})()</script><title>《C++并发线程实战》杂记 [ Hexo ]</title><link rel="stylesheet" href="/css/partial/footer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="stylesheet" href="/css/partial/sidebar.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="scroll"><link rel="stylesheet" href="/css/partial/header.css"><div class="header scroll"><div class="maxwidth"><div class="nav"><a id="artlist" href="/404"><i class="iconfont icon404"></i><span class="headhid">&nbsp;404</span></a><a id="artlist" href="/archives"><i class="iconfont iconarchives"></i><span class="headhid">&nbsp;Archives</span></a><a id="artlist" href="/link"><i class="iconfont iconlink"></i><span class="headhid">&nbsp;Link</span></a><a id="artlist" href="/about"><i class="iconfont iconabout"></i><span class="headhid">&nbsp;About</span></a></div><div class="search">TONG-H</div></div></div><div class="main"> <div class="maxwidth"><link rel="stylesheet" href="/css/partial/sidebar.css"><div class="scroll" id="sidebar"><div class="social"><a href="/archives" title="Home"><i class="iconfont iconHome"></i></a><a href="1813828837@qq.com" title="E-Mail"><i class="iconfont iconweibiaoti554"></i></a><a target="_blank" rel="noopener" href="https://github.com/Ginkgowind" title="GitHub"><i class="iconfont iconGitHub"></i></a></div><div class="structure category-list"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">第2章 线程管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">第3章 线程间共享数据</span></a></li></ol></div><div class="tags"><a href="/tags/C/" style="font-size: 12px; color: #ffac00">C++</a> <a href="/tags/UE4/" style="font-size: 12px; color: #ffac00">UE4</a> <a href="/tags/cs/" style="font-size: 12px; color: #ffac00">cs</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 12px; color: #ffac00">图形学</a> <a href="/tags/%E5%A5%BD%E6%96%87%E6%8E%A8%E8%8D%90/" style="font-size: 12px; color: #ffac00">好文推荐</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px; color: #ffac00">数据结构</a></div></div><div class="post rightside"><div class="artititle">《C++并发线程实战》杂记</div><div class="info"><i class="iconfont iconbiaoqian" title="文章标签"><span>C++</span></i><i class="iconfont iconshijian"><span title="文章发布时间">2022-09-03</span></i></div><div class="postDetail"><h1 id="第2章-线程管理"><a href="#第2章-线程管理" class="headerlink" title="第2章 线程管理"></a>第2章 线程管理</h1><p>线程以一个函数作为入口，函数执行完线程也就结束了。</p>
<p><strong>类型：</strong>启动了线程之后要明确是加入式(.join)还是分离式(.detach)。在一个函数执行完后，会收回函数内所执行的线程，所以可通过.join()来阻塞，或通过.detach()来分离，通常称分离线程为守护线程。两者使用前都需要通过.joinable()来检查。文档编辑器打开的多个文档就是分离线程。</p>
<p><strong>向线程函数传参：</strong>实例化线程时括号里函数名后面加上参数即可。注意std::thread的构造函数已经实现好，传的值都是拷贝，所以传引用要使用ref，后续再深入了解吧。</p>
<p><strong>转移线程所有权</strong>：可使用std::move()。</p>
<p><strong>运行时决定线程数量</strong>：书中实现了一个并行版本的accumulate函数，考虑了系统允许的线程最大数量。</p>
<p><strong>标识线程</strong>：get_id()。可以通过判断ID来区分是不是主线程，从而确定要做的任务。</p>
<h1 id="第3章-线程间共享数据"><a href="#第3章-线程间共享数据" class="headerlink" title="第3章 线程间共享数据"></a>第3章 线程间共享数据</h1><p><strong>共享数据带来的问题</strong>：修改数据时会遇到此问题，条件竞争。并发地修改双向链表会出错，并发地向队列添加元素不会。</p>
<p><u><em>注：RAII机制是一种编程方式，一般指对现有的数据结构进行封装，在析构函数里进行释放、线程join，等等。（本来设置了斜体但网页中不显示。。。有空问问别人咋整）</em></u></p>
<p><strong>使用互斥量保护共享数据</strong>：</p>
<ol>
<li>C++中使用互斥量：C++中通过实例化 std::mutex 创建互斥量实例，通过成员函数lock()对互斥量上锁，unlock() 进行解锁。也可用std::lock_guard。提防后门：当其中一个成员函数返回的是保护数据的指针或引用时，会破坏数据。（因为暂时不知锁的具体实现方式，所以先不深究）</li>
<li>用代码保护共享数据：给了一个破坏数据的例子。</li>
<li>定位接口间的条件竞争：有些接口的实现是无锁编程，用stack举了例子。实现了一个线程安全的stack，没看懂，以后再看。</li>
<li>死锁的问题描述及解决方案：</li>
</ol>
<p>产生的四个必要条件：</p>
<p><strong>互斥：</strong>资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</p>
<p><strong>占有并等待：</strong>一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</p>
<p><strong>非抢占：</strong>资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</p>
<p><strong>循环等待：</strong>有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。</p>
<p>5. </p>
<p><strong>看着实在费力，以后闲下来了再看吧。先去看通用的OS了</strong></p>
</div></div><link rel="stylesheet" href="/css/partial/footer.css"><div class="footer"><p><span>Copyright © 2017 - 2022  </span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">蜀ICP备19024124号</a></p><p><i class="iconfont iconchakan"><span>本站总访问量</span><span id="busuanzi_container_site_pv">  <span id="busuanzi_value_site_pv"></span> </span></i><i class="iconfont iconabout"><span>本站访客数</span><span id="busuanzi_container_site_uv">  <span id="busuanzi_value_site_uv"></span> </span></i></p></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>