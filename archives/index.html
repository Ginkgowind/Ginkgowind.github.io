<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords"><meta name="descriptioon" content=""><meta name="renderer" content="wekit"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/public.css"><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="/css/iconfont.css"><script>var _hmt = _hmt || [];(function(){var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?7b429839b56cf831028b7ac4cb9b5086";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})()</script><title>博客 [ Hexo ]</title><link rel="stylesheet" href="/css/partial/footer.css"><link rel="stylesheet" href="/css/partial/posts.css"><link rel="stylesheet" href="/css/partial/posts.css"><link rel="stylesheet" href="/css/partial/sidebar.css"><link rel="stylesheet" href="/css/archive.css"><link rel="stylesheet" href="/css/index.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="scroll"><link rel="stylesheet" href="/css/partial/header.css"><div class="header scroll"><div class="maxwidth"><div class="nav"><a id="artlist" href="/404"><i class="iconfont icon404"></i><span class="headhid">&nbsp;404</span></a><a class="focuspage" id="artlist" href="/archives"><i class="iconfont iconarchives"></i><span class="headhid">&nbsp;Archives</span></a><a id="artlist" href="/link"><i class="iconfont iconlink"></i><span class="headhid">&nbsp;Link</span></a><a id="artlist" href="/about"><i class="iconfont iconabout"></i><span class="headhid">&nbsp;About</span></a></div><div class="search">TONG-H</div></div></div><div class="main"> <div class="maxwidth"><link rel="stylesheet" href="/css/partial/sidebar.css"><div class="scroll" id="sidebar"><div class="social"><a href="/archives" title="Home"><i class="iconfont iconHome"></i></a><a href="1813828837@qq.com" title="E-Mail"><i class="iconfont iconweibiaoti554"></i></a><a target="_blank" rel="noopener" href="https://github.com/Ginkgowind" title="GitHub"><i class="iconfont iconGitHub"></i></a></div><div class="tags"><a href="/tags/C/" style="font-size: 12px; color: #ffac00">C++</a> <a href="/tags/UE4/" style="font-size: 12px; color: #ffac00">UE4</a> <a href="/tags/cs/" style="font-size: 12px; color: #ffac00">cs</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 12px; color: #ffac00">图形学</a> <a href="/tags/%E5%A5%BD%E6%96%87%E6%8E%A8%E8%8D%90/" style="font-size: 12px; color: #ffac00">好文推荐</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px; color: #ffac00">数据结构</a></div></div><div class="archive rightside"><div id="list_archives" style="opacity: 0;display:  none"><div class="switch" id="arshow"><i class="iconfont iconArchives"></i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">7</span></li></ul></div><div id="normalposts"><div class="switch" id="poshow"><i class="iconfont iconshijian"></i></div><article><a class="artititle" href="/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><div class="content ellipse"><p>以下文章请按顺序阅读

5种构建型模式知乎：如何用「设计模式」制作珍珠奶茶？
简单工厂模式、工厂方法模式、抽象工厂模式
单例模式，两种实现方式（补充：C++单例模式，内含有关线程安全等的C++实现，重点是static）
建造型模式
简短总结

简单工厂模式：switch实现，在绝大多数情况下， 简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤。缺点如下：

生产商品类型过多时会变成超级类，并且每个产品生产过程变化时都需要来修改此工厂，也就是说这个类不止一个引起修改的原因，也就是违反了单一职责原则。
添加新功能时需要修改现有的类，违反了开闭原则。


工厂方法模式：基类工厂提供一个接口，每个子类工厂都实现此接口。将构造过程封装了起来，但核心作用还没搞明白。同时解决了简单工厂的两个弊端，但引入了太多的类。


抽象工厂模式：抽象工厂基类声明一组创建各种抽象产品的方法，每个具体工厂都实...</p></div><div class="meta"><i class="iconfont iconshijian" title="创建时间">2022-09-10</i></div></article><article><a class="artititle" href="/2022/09/10/GAMES101%E6%95%B4%E7%90%86/">《GAMES101》整理</a><div class="content ellipse"><p>基于《GAMES101》课程整理自CSDN某位博主


一：基础变换矩阵总结(缩放，旋转，位移)
2D线性变换
缩放





剪切



旋转



3D线性变换
缩放





剪切



旋转



绕任意轴旋转：我们把该轴给先旋转到任意的x，y，z轴上，然后就可以应用基本的旋转矩阵，最后再逆旋转回来即可。



放射变换
位移




一(补充)：特征分解和奇异值分解的几何解释CSDN博客链接
二：视图变换(坐标系转化，正交投影，透视投影，视口变换)注：MVP变换

模型变换(modeling tranformation)：利用基础的变换矩阵将世界当中的物体调整至我们想要的地方(旋转，平移，缩放)。
摄像机变换(camera&#x2F;view tranformation)：得到所有可视物体与摄像机的相对位置。把物体和摄像机一起做移动，如果能够把摄像机的坐标轴(假设为u,v,...</p></div><div class="meta"><i class="iconfont iconshijian" title="创建时间">2022-09-10</i></div></article><article><a class="artititle" href="/2022/09/03/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E6%9D%82%E8%AE%B0/">《C++并发线程实战》杂记</a><div class="content ellipse"><p>第2章 线程管理线程以一个函数作为入口，函数执行完线程也就结束了。
类型：启动了线程之后要明确是加入式(.join)还是分离式(.detach)。在一个函数执行完后，会收回函数内所执行的线程，所以可通过.join()来阻塞，或通过.detach()来分离，通常称分离线程为守护线程。两者使用前都需要通过.joinable()来检查。文档编辑器打开的多个文档就是分离线程。
向线程函数传参：实例化线程时括号里函数名后面加上参数即可。注意std::thread的构造函数已经实现好，传的值都是拷贝，所以传引用要使用ref，后续再深入了解吧。
转移线程所有权：可使用std::move()。
运行时决定线程数量：书中实现了一个并行版本的accumulate函数，考虑了系统允许的线程最大数量。
标识线程：get_id()。可以通过判断ID来区分是不是主线程，从而确定要做的任务。
第3章 线程间共享数...</p></div><div class="meta"><i class="iconfont iconshijian" title="创建时间">2022-09-03</i></div></article><article><a class="artititle" href="/2022/09/03/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%E6%8E%A8%E8%8D%90/">搭建个人博客教程推荐</a><div class="content ellipse"><p>本人博客搭建就是用的这两个教程，内容很详细靠谱

使用说明：先看教程1来搭博客，里面涉及到图床的部分可以先略过，搭好之后可以看教程2

知乎：“GitHub+Hexo 搭建个人网站详细教程”

https://zhuanlan.zhihu.com/p/26625249

知乎：“使用Github+picGo搭建图床，保姆级教程来了”

https://zhuanlan.zhihu.com/p/489236769</p></div><div class="meta"><i class="iconfont iconshijian" title="创建时间">2022-09-03</i></div></article><article><a class="artititle" href="/2022/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><div class="content ellipse"><p>一、十大排序1、冒泡排序 O(n2) 稳定以构造递增数组为例双层循环，从前往后依次比较两个相邻元素，若前一个大于后一个，就交换。让数组从后往前，每一个当前元素都是剩余元素最大的。
1234567for( int i = 0 ; i &lt; len - 1 ; i++ )&#123;    for(int j = 0;j &lt; len - 1 - i ; j++)&#123;        if(arr[j] &gt; arr[j + 1])&#123;            swap(arr[j],arr[j+1]);        &#125;    &#125;&#125;
2、选择排序 O(n2) 不稳定双层循环，每一轮记录最小元素的下标，并交换到循环开始的位置
3、插入排序 O(n2) 稳定类似于整理手里的扑克牌从前往后依次取出，记为value，并往前比较，如果大于va...</p></div><div class="meta"><i class="iconfont iconshijian" title="创建时间">2022-09-03</i></div></article><article><a class="artititle" href="/2022/09/02/InsideUE4%E2%80%94%E2%80%94GamePlay%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/">InsideUE4——GamePlay框架总结</a><div class="content ellipse"><p>个人总结
为了面试口述，内容有省略，后续会完善。大钊也表示Damage确实不是AActor应该管的事情。

首先是UObject，提供了反射、GC、序列化等等属性，因为提供了很强大的这些基本属性，UObject基本是UE中一切类的起源。
Actor就是继承于UObject，添加了网络复制、Tick等等。Actor在UE中既包含具象化的实体，也包含一些看不到的信息、状态、规则，比如AInfo系列（GameMode、GameState这些）。所以Actor并不是自带Transform的，而是将Transform封装到了SceneComponent当做RootComponent，对外暴露出GetActorLocation这些。至于为什么要将Info继承自Actor而不是另起一套，我觉得可能是需要Tick、网络复制等等，但是Component、Damage对于Info来说又好像确实是冗余的，...</p></div><div class="meta"><i class="iconfont iconshijian" title="创建时间">2022-09-02</i></div></article><article><a class="artititle" href="/2022/09/01/hello-world/">Hello World</a><div class="content ellipse"><p>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;

More info: Writing
Run server1$ hexo server

More info: Server
Generate static files1$ hexo generate

More info: Generating
Deploy to rem...</p></div><div class="meta"><i class="iconfont iconshijian" title="创建时间">2022-09-01</i></div></article><div id="paginator"><span class="page-number current">1</span></div></div><script>document.getElementById('arshow').onclick = function() {
    document.getElementById('list_archives').style = 'opacity: 0;display: none'
    document.getElementById('normalposts').style = 'opacity: 0;display: block'
    setTimeout(() => {
        document.getElementById('normalposts').style.opacity = '1'                        
    }, 100);
}
document.getElementById('poshow').onclick = function() {
    document.getElementById('normalposts').style = 'opacity: 0;display: none'
    document.getElementById('list_archives').style = 'opacity: 1;display: block'
}</script></div><link rel="stylesheet" href="/css/partial/footer.css"><div class="footer"><p><span>Copyright © 2017 - 2022  </span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">蜀ICP备19024124号</a></p><p><i class="iconfont iconchakan"><span>本站总访问量</span><span id="busuanzi_container_site_pv">  <span id="busuanzi_value_site_pv"></span> </span></i><i class="iconfont iconabout"><span>本站访客数</span><span id="busuanzi_container_site_uv">  <span id="busuanzi_value_site_uv"></span> </span></i></p></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>